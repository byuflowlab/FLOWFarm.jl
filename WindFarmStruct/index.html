<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Wind Farm Struct · FLOWFarm.jl</title><meta name="title" content="Wind Farm Struct · FLOWFarm.jl"/><meta property="og:title" content="Wind Farm Struct · FLOWFarm.jl"/><meta property="twitter:title" content="Wind Farm Struct · FLOWFarm.jl"/><meta name="description" content="Documentation for FLOWFarm.jl."/><meta property="og:description" content="Documentation for FLOWFarm.jl."/><meta property="twitter:description" content="Documentation for FLOWFarm.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FLOWFarm.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Intro</a></li><li><a class="tocitem" href="../Tutorial/">Quick Start</a></li><li class="is-active"><a class="tocitem" href>Wind Farm Struct</a><ul class="internal"><li><a class="tocitem" href="#Farm-Struct"><span>Farm Struct</span></a></li><li><a class="tocitem" href="#Constraint-Structs"><span>Constraint Structs</span></a></li><li class="toplevel"><a class="tocitem" href="#Sparsity-Options"><span>Sparsity Options</span></a></li><li><a class="tocitem" href="#Farm-Sparsity"><span>Farm Sparsity</span></a></li><li><a class="tocitem" href="#Constraint-Sparsity"><span>Constraint Sparsity</span></a></li><li><a class="tocitem" href="#Sparse-Objective-Function-in-SNOW"><span>Sparse Objective Function in SNOW</span></a></li></ul></li><li><a class="tocitem" href="../How_to/">How-to Guide</a></li><li><a class="tocitem" href="../Explanation/">Theory</a></li><li><a class="tocitem" href="../Reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Wind Farm Struct</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Wind Farm Struct</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/byuflowlab/FLOWFarm.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/master/docs/src/WindFarmStruct.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Wind-Farm-Struct"><a class="docs-heading-anchor" href="#Wind-Farm-Struct">Wind Farm Struct</a><a id="Wind-Farm-Struct-1"></a><a class="docs-heading-anchor-permalink" href="#Wind-Farm-Struct" title="Permalink"></a></h1><p>This tutorial covers the usage of the wind farm struct. The wind farm struct simplifies optimization set up and allows for the use of sparse methods in gradient calculation. The AEP value and the gradient are both stored in the farm struct</p><h2 id="Farm-Struct"><a class="docs-heading-anchor" href="#Farm-Struct">Farm Struct</a><a id="Farm-Struct-1"></a><a class="docs-heading-anchor-permalink" href="#Farm-Struct" title="Permalink"></a></h2><p>All of the setup from the previous tutorial sections 1 and 2 is required. Then the wind farm struct in defined.</p><pre><code class="nohighlight hljs">function my_update_function(farm,x)
    farm.turbine_x .= x[1:length(x)÷2]
    farm.turbine_y .= x[length(x)÷2+1:end]
end

farm = ff.build_wind_farm_struct(x0, x, y, turbine_z, hub_height, turbine_yaw, rotor_diameter, ct_models, generator_efficiency, cut_in_speed, cut_out_speed, rated_speed, rated_power, windresource, power_models, model_set, my_update_function; AEP_scale=1.0, input_type=&quot;ForwardDiff&quot;, opt_x=true, opt_y=true)</code></pre><p>build<em>wind</em>farm_struct has many inputs and options. While most are well defined in the previous tutorial, some are new. </p><ul><li><code>x0</code> is a vector of the design variables and should already be scaled. </li><li><code>my_update_function</code> is a function that is of the form <code>f(wind_farm_struct, design_variables)</code> and updates the wind farm struct in place from the design variables.</li><li><code>AEP_scale</code> applies a scale factor to the AEP calculation and by default uses <code>1.0/ideal_AEP</code>.</li><li><code>input_type</code> is FowardDiff when using the farm struct for optimization. Otherwise, deafults to <code>nothing</code> and will use the type of <code>x0</code></li><li><code>opt_x</code>, <code>opt_y</code>, <code>opt_hub</code>, <code>opt_yaw</code>, and <code>opt_diam</code> determine which variables are being optimized so that only those variables are stored as <code>input_type</code>. This allows for faster gradient computation.</li></ul><h2 id="Constraint-Structs"><a class="docs-heading-anchor" href="#Constraint-Structs">Constraint Structs</a><a id="Constraint-Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-Structs" title="Permalink"></a></h2><p>Constraint structs are also provided for both spacing and boundary constraints.</p><pre><code class="nohighlight hljs">spacing = 2.0 * rotor_diameter[1] # 2 rotor diameters spacing between turbines
scaling = 1.0/rotor_diameter[1]^2 # scaling factor for spacing constraint
spacing_struct = ff.build_spacing_struct(x0, num_turbines, spacing, scaling, my_update_function)

boundary_function(a,x,y) = ff.circle_boundary!(a, boundary_center, boundary_radius, x, y) # boundary function, must be in-place and take the form f(a,x,y) where a is the constraint values
n_constraints = num_turbines # number of boundary constraints
scaling = 1.0/boundary_radius^2 # scaling factor for boundary constraint
boundary_struct = ff.build_boundary_struct(x0, num_turbines, n_constraints, scaling, boundary_function, my_update_function)</code></pre><p>The resulting objective function then looks like:</p><pre><code class="nohighlight hljs">function opt!(g,df,dg,x,farm,spacing_struct,boundary_struct)

    # calculate spacing constraint value and jacobian
    ff.calculate_spacing_jacobian!(spacing_struct,x)

    # calculate boundary constraint and jacobian
    ff.calculate_boundary_jacobian!(boundary_struct,x)

    # combine constaint values and jacobians into overall constaint value and jacobian arrays
    c = [spacing_struct.spacing_vec; boundary_struct.boundary_vec]
    g[:] .= ((c[:]))
    dg[:] = (([spacing_struct.jacobian; boundary_struct.jacobian]))

    # calculate AEP and gradient
    ff.calculate_aep_gradient!(farm,x)

    AEP = -farm.AEP[1]
    df[:] .= ((-farm.AEP_gradient))

    return AEP
end

# Force signature to allow for pass into SNOW.minimize
opt!(g,df,dg,x) = opt!(g,df,dg,x,farm,spacing_struct,boundary_struct)</code></pre><h1 id="Sparsity-Options"><a class="docs-heading-anchor" href="#Sparsity-Options">Sparsity Options</a><a id="Sparsity-Options-1"></a><a class="docs-heading-anchor-permalink" href="#Sparsity-Options" title="Permalink"></a></h1><p>Using sparsity can greatly accelerate wind farm optimization. For detailed theory please see</p><pre><code class="nohighlight hljs">Varela, B., and Ning, A., “Sparsity Applications for Gradient-Based Optimization of Wind Farms,” Oct. 2024, (in review).</code></pre><p>The use of sparsity is built into FLOWFarm for user convenience.</p><h2 id="Farm-Sparsity"><a class="docs-heading-anchor" href="#Farm-Sparsity">Farm Sparsity</a><a id="Farm-Sparsity-1"></a><a class="docs-heading-anchor-permalink" href="#Farm-Sparsity" title="Permalink"></a></h2><p>There are two types of sparsity used in calculating the gradient of the AEP, stable and unstable sparsity. Stable sparsity refers to the situation where the sparsity pattern does not change during the optimization. Unstable sparsity refers to situations where the sparsity pattern may change during the optimzation. The sparsity pattern referred to depends on how each turbine affects the power produced by every other turbine due to its wake interference. </p><p>For example, any optimization where the x or y positions of the turbines are design variables will result in changing sparsity patterns as the turbines move and interact with different turbines. In contrast a yaw optimization is unlikely to cause a change in the sparsity pattern during the optimization.</p><p>Use of sparsity in AEP optimization requires a sparse_struct that must be passed into the objective function in the same manner as constraint structs. The AEP and the AEP gradient are then stored in the farm struct just as with non-sparse methods</p><pre><code class="nohighlight hljs">ff.calculate_aep_gradient!(farm,x0,sparse_struct)
println(&quot;AEP = &quot;,farm.AEP[1])
println(&quot;AEP Gradient = &quot;,farm.AEP_gradient)</code></pre><h3 id="Stable-Sparsity"><a class="docs-heading-anchor" href="#Stable-Sparsity">Stable Sparsity</a><a id="Stable-Sparsity-1"></a><a class="docs-heading-anchor-permalink" href="#Stable-Sparsity" title="Permalink"></a></h3><p>Stable sparse farm structs are constructed in a similar method to regular farm structs</p><pre><code class="nohighlight hljs">farm, sparse_struct = ff.build_stable_sparse_struct(x0, x, y, turbine_z, hub_height, turbine_yaw, rotor_diameter, ct_models, generator_efficiency, cut_in_speed, cut_out_speed, rated_speed, rated_power, windresource, power_models, model_set, my_update_function_yaw; AEP_scale=1.0, opt_yaw=true, tolerance=1E-16)</code></pre><p>The only new parameter is <code>tolerance</code> which defaults to 1E-16. This tolerance is used when computing the sparsity pattern. When creating the <code>sparse_struct</code> the sparsity pattern is computed by calculating the partial derivatives of the power of each turbine with respect to each design variable. Then, all partial derivatives with a magnitude below the <code>tolerance</code> are ignored in the sparsity pattern. The default value is safe for almost all cases and the effect of the <code>tolerance</code> is explored more in the above paper. </p><p>Important note: <code>build_stable_sparse_struct</code> attempts to calculate an accurate sparsity pattern by perturbing all of the design variables randomly to avoid poor starting locations where derivatives zero out, such as in yaw optimization when the turbine faces directly into the wind. While this does help get an accurate sparsity pattern it is advised to call <code>build_stable_sparse_struct</code> with <code>x0</code> set to a reasonable start point to avoid derivatives that are not representative of the influence of the design variable.</p><h3 id="Unstable-Sparsity"><a class="docs-heading-anchor" href="#Unstable-Sparsity">Unstable Sparsity</a><a id="Unstable-Sparsity-1"></a><a class="docs-heading-anchor-permalink" href="#Unstable-Sparsity" title="Permalink"></a></h3><p>Unstable sparse methods can always be used as the sparsity pattern is recomputed at each iteration using the wake deficits from the AEP calculation, but unstable sparse methods are not as efficient as stable sparse methods, again see the theory paper.</p><p>Unstable sparse structs are computed in the same way as stable sparse struct with a different function call.</p><pre><code class="nohighlight hljs">farm, sparse_struct = ff.build_unstable_sparse_struct(x0, x, y, turbine_z, hub_height, turbine_yaw, rotor_diameter, ct_models, generator_efficiency, cut_in_speed, cut_out_speed, rated_speed, rated_power, windresource, power_models, model_set, my_update_function_yaw; AEP_scale=1.0, opt_yaw=true, tolerance=1E-16)</code></pre><h2 id="Constraint-Sparsity"><a class="docs-heading-anchor" href="#Constraint-Sparsity">Constraint Sparsity</a><a id="Constraint-Sparsity-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-Sparsity" title="Permalink"></a></h2><h3 id="Boundary-Constraints"><a class="docs-heading-anchor" href="#Boundary-Constraints">Boundary Constraints</a><a id="Boundary-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Constraints" title="Permalink"></a></h3><p>The boundary constraint structs use sparsity by default as it has not effect on the solutions and little effect on the computation speed. This can be turned off with <code>using_sparsity=false</code>.</p><h3 id="Spacing-Constraints"><a class="docs-heading-anchor" href="#Spacing-Constraints">Spacing Constraints</a><a id="Spacing-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Spacing-Constraints" title="Permalink"></a></h3><p>The use of sparsity in spacing constraints is more complicated than with the farm AEP and requires at least 2 optimizations. First an optimization is performed with no spacing constraints, then a second optimization is performed with select spacing constraints.</p><p>The function call for building a sprase spacing struct is</p><pre><code class="nohighlight hljs">sparse_spacing_struct = ff.build_sparse_spacing_struct(x0, x, y, spacing, scaling, spacing_update_function!; first_opt=true, relevant_spacing_factor=2)

ff.calculate_spacing_jacobian!(sparse_spacing_struct,x)</code></pre><p><code>first_opt</code> defaults to true and causes no spacing constraints to be calculated, resulting in empty spacing jacobian and spacing constraints objects. This is done to allow the objective function to remain unchanged between the first and second optimizations. <code>first_opt</code> should be set to false when creating the spacing struct for the second optimization <code>relevant_spacing_factor</code> defaults to 2 and determines which spacing constraints are relevant during the optimization by only including constraints where turbine pairs are within <code>spacing</code> * <code>relevant_spacing_factor</code> from eachother. These constraints are determined based on the x and y passed into the build function.</p><p>By using no spacing constraints in the first optimization the design space is freed from many constraints, causing the solution to be improved and reached faster. The second optimization is then short as an optimum has been reached and only a small number of spacing constraints must be satisfied. This works well, but depending on your optimizer the second optimization can be difficult if started from a position that violates constraints. To ease this sparse spacing structs can store the last position that satisfied all the spacing constraints during the first optimization. </p><pre><code class="nohighlight hljs">ff.update_safe_design_variables!(sparse_spacing_struct,x)</code></pre><p><code>spacing_struct.safe_design_variables</code> can then be used as the start point for the second optimization.</p><p>The computing of the spacing constraints during the first optimization to determine if any are violated is minimal as the speed up of the optimization is caused by the optimizer having less constraints to satisfy.</p><h2 id="Sparse-Objective-Function-in-SNOW"><a class="docs-heading-anchor" href="#Sparse-Objective-Function-in-SNOW">Sparse Objective Function in SNOW</a><a id="Sparse-Objective-Function-in-SNOW-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Objective-Function-in-SNOW" title="Permalink"></a></h2><p>When giving constraints to SNOW.jl it is possible to give the optimizer a sparse set of constaints whether or not the sparse structs are used. This is shown in the following using <code>sp</code>. </p><pre><code class="nohighlight hljs">function opt!(g,df,dg,x,farm,spacing_struct,boundary_struct,sp,sparse_struct)

    ff.update_safe_design_variables!(spacing_struct,x)

    # calculate spacing constraint value and jacobian
    ff.calculate_spacing_jacobian!(spacing_struct,x)

    # calculate boundary constraint and jacobian
    ff.calculate_boundary_jacobian!(boundary_struct,x)

    # combine constaint values and jacobians into overall constaint value and jacobian arrays
    c = [spacing_struct.spacing_vec; boundary_struct.boundary_vec]
    g[:] .= ((c[:]))

    dcdx = (sparse([spacing_struct.jacobian; boundary_struct.jacobian]))
    for i = 1:length(sp.rows)
        dg[i] = dcdx[sp.rows[i],sp.cols[i]]
    end

    # calculate the objective function and jacobian (negative sign in order to maximize AEP)
    ff.calculate_aep_gradient!(farm,x,sparse_struct)

    AEP = -farm.AEP[1]

    df[:] .= ((-farm.AEP_gradient))

    return AEP
end</code></pre><p><code>sp</code> is calculated as follows assuming that the constraint jacobians have already been calculated.</p><pre><code class="nohighlight hljs">sp = SNOW.SparsePattern(sparse(dropzeros(vcat(spacing_struct.jacobian,boundary_struct.jacobian))))</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Tutorial/">« Quick Start</a><a class="docs-footer-nextpage" href="../How_to/">How-to Guide »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Tuesday 18 February 2025 20:55">Tuesday 18 February 2025</span>. Using Julia version 1.10.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
