var documenterSearchIndex = {"docs":
[{"location":"How_to/#How-to-Guide","page":"How-to Guide","title":"How-to Guide","text":"","category":"section"},{"location":"How_to/#Multi-threading","page":"How-to Guide","title":"Multi-threading","text":"","category":"section"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"Multi-threading is available for the calculation of annual energy production (AEP). It can be enabled as follows in a bash terminal in Linux/OS prior to launching a julia session:","category":"page"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"export JULIA_NUM_THREADS=<number of threads>","category":"page"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"For enabling multi-threading on other shells/systems please see the julia parallel-computing docs here: https://docs.julialang.org/en/v1/manual/parallel-computing/.","category":"page"},{"location":"How_to/#Distributed-Processing","page":"How-to Guide","title":"Distributed Processing","text":"","category":"section"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"Distributed parallel processing is available for the calculation of annual energy production (AEP). ","category":"page"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"You may have to add using Distributed to your julia script and use the @everywhere macro  in front of any functions you define that all processors will need access to. For an example,  see example_opt_6_38turb_round_distributed.jl.","category":"page"},{"location":"How_to/#Using-Distributed-Processing-without-an-HPC-Cluster-Manager-(e.g.-on-your-local-system)","page":"How-to Guide","title":"Using Distributed Processing without an HPC Cluster Manager (e.g. on your local system)","text":"","category":"section"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"Distributed parallel processing can be enabled as follows when launching a julia session:","category":"page"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"julia -p <number of processors>","category":"page"},{"location":"How_to/#Using-Distributed-Processing-with-an-HPC-Cluster-Manager-(e.g.-SLURM)","page":"How-to Guide","title":"Using Distributed Processing with an HPC Cluster Manager (e.g. SLURM)","text":"","category":"section"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"The -p option to the julia call is unnecessary when running with a cluster manager.  To work with cluster managers, add the following to your julia script (this example is for  SLURM, but other managers are available as well):","category":"page"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"using Distributed\nusing ClusterManagers\n\naddprocs(SlurmManager(parse(Int, ENV[\"SLURM_NTASKS\"])-1))\n@everywhere import FLOWFarm; const ff = FLOWFarm","category":"page"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"Also include the @everywhere macro in front of any function definitions or include statements in your julia script that all processors will need access to.","category":"page"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"Your SLURM job script should look something like this:","category":"page"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"#!/bin/bash -l\n#SBATCH --ntasks=100\n#SBATCH --mem-per-cpu=1024M   # memory per CPU core\n#SBATCH --time=01:00:00 # time=HH:MM:SS\n#SBATCH -J \"Your job name here\"   # job name\n\nmodule load julia\n\njulia julia_script.jl","category":"page"},{"location":"How_to/","page":"How-to Guide","title":"How-to Guide","text":"References For more information on using julia in a distributed environment, please see https://docs.julialang.org/en/v1/manual/parallel-computing/.","category":"page"},{"location":"Reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"Reference/","page":"Reference","title":"Reference","text":"Modules = [FLOWFarm]","category":"page"},{"location":"Reference/#FLOWFarm.CumulativeCurl","page":"Reference","title":"FLOWFarm.CumulativeCurl","text":"CumulativeCurl(a_s, b_s, c_s1, c_s2, a_f, b_f, c_f)\n\nContainer for parameters related to the Cumulative Curl model used in FLORIS v3 as shown in Bay 2022 (https://doi.org/10.5194/wes-2022-17)\n\nArguments\n\na_s::Float: parameter relating turbulence intensity to wake spread. Default value is 0.179367259\nb_s::Float: parameter controlling the default wake spread. Default value is 0.0118889215\nc_s1::Float: parameter relating Ct to initial wake width. Default value is 0.0563691592\nc_s2::Float: parameter affecting initial wake width. Default value is 0.13290157\na_f::Float: Default value is 3.11\nb_f::Float: Default value is -0.68\nc_f::Float: Default value is 2.41\n'wec_factor': paramter for the wake expansion continuation Default is [1.0]\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.DiscretizedWindResource","page":"Reference","title":"FLOWFarm.DiscretizedWindResource","text":"DiscritizedWindResource(wind_directions, wind_speeds, wind_probabilities, measurement_heights, air_density, ti_model, wind_shear_model)\n\nStruct defining a wind resource\n\nArguments\n\nwind_directions::Array{Float,1}(Nstates): an array of wind directions corresponding to each wind farm state in radians\nwind_speeds::Array{Float,1}(Nstates): an array of wind speeds corresponding to each wind farm state in meters/second\nwind_probabilities::Array{Float,1}(Nstates): an array of probabilities corresponding to each wind farm state with values in [0,1]\nmeasurement_heights::Array{Float,1}(Nstates): an array of measurement heights corresponding to each wind farm state\nair_density::Float: the air density\nambient_ti::Array{Float,1}: an array of the ambient turbulence intensity for each wind direction\nwind_shear_model::Array{AbstractWindShearModel}(1): contains a struct defining the desired turbulence intensity model\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.GaussOriginal","page":"Reference","title":"FLOWFarm.GaussOriginal","text":"GaussOriginal(k_star)\n\nContainer for parameters related to the origina Gaussian deficit model presented by Bastankhah and Porte-Agel 2014\n\nArguments\n\nk_star::Float: parameter controlling the wake spreading rate and deficit decay. Default value is 0.075\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.GaussSimple","page":"Reference","title":"FLOWFarm.GaussSimple","text":"GaussSimple(k, wec_factor)\n\nContainer for parameters related to the Gaussian deficit model with yaw presented by Bastankhah and Porte-Agel 2016\n\nArguments\n\nk::Float: parameter controlling the spread of the wake\nwec_factor::Array{Float}: parameter artificial wake spreading for wake expansion continuation (WEC) optimization\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.GaussYaw","page":"Reference","title":"FLOWFarm.GaussYaw","text":"GaussYaw(turbulence_intensity, horizontal_spread_rate, vertical_spread_rate, alpha_star, beta_star, interpolation)\n\nContainer for parameters related to the Gaussian deficit model with yaw presented by Bastankhah and Porte-Agel 2016\n\nArguments\n\nhorizontal_spread_rate::Float: parameter controlling the horizontal spread of the deficit model. Default value is 0.022.\nvertical_spread_rate::Float: parameter controlling the vertical spread of the deficit model. Default value is 0.022.\nalpha_star::Float: parameter controlling the impact of turbulence intensity on the length of the near wake. Default value is 2.32.\nbeta_star::Float: parameter controlling the impact of the thrust coefficient on the length of the near wake. Default value is 0.154.\ninterpolation::Bool: boolean stating if the the near wake should be interpolated. Default value is true.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.GaussYawDeflection","page":"Reference","title":"FLOWFarm.GaussYawDeflection","text":"GaussYawDeflection(horizontal_spread_rate, vertical_spread_rate, alpha_star, beta_star, interpolation)\n\nContainer for parameters related to the Gaussian deflection model presented by Bastankhah and Porte-Agel 2016\n\nArguments\n\nhorizontal_spread_rate::Float: parameter controlling the horizontal spread of the deficit model. Default value is 0.022.\nvertical_spread_rate::Float: parameter controlling the vertical spread of the deficit model. Default value is 0.022.\nalpha_star::Float: parameter controlling the impact of turbulence intensity on the length of the near wake. Default value is 2.32.\nbeta_star::Float: parameter controlling the impact of the thrust coefficient on the length of the near wake. Default value is 0.154.\ninterpolation::Bool: boolean stating if the the near wake should be interpolated. Default value is true.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.GaussYawVariableSpread","page":"Reference","title":"FLOWFarm.GaussYawVariableSpread","text":"GaussYawVariableSpread(turbulence_intensity, horizontal_spread_rate, vertical_spread_rate, alpha_star, beta_star, interpolation)\n\nContainer for parameters related to the Gaussian deficit model with yaw presented by Bastankhah and Porte-Agel 2016     and the farm model presented by Niayifar and Porte-Agel in 2016.\n\nArguments\n\nalpha_star::Float: parameter controlling the impact of turbulence intensity on the length of the near wake. Default value is 2.32.\nbeta_star::Float: parameter controlling the impact of the thrust coefficient on the length of the near wake. Default value is 0.154.\ninterpolation::Bool: boolean stating if the the near wake should be interpolated. Default value is true.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.GaussYawVariableSpreadDeflection","page":"Reference","title":"FLOWFarm.GaussYawVariableSpreadDeflection","text":"GaussYawDeflectionVariableSpread(alpha_star, beta_star, k1, k2, interpolation)\n\nContainer for parameters related to the Gaussian deflection model with yaw presented by Bastankhah and Porte-Agel 2016\n\nArguments\n\nalpha_star::Float: parameter controlling the impact of turbulence intensity on the length of the near wake. Default value is 2.32.\nbeta_star::Float: parameter controlling the impact of the thrust coefficient on the length of the near wake. Default value is 0.154.\nk1::Float: first parameter tuning wake spread as based on turbulence intensity\nk2::Float: second parameter tuning wake spread as based on turbulence intensity\ninterpolation::Bool: boolean stating if the the near wake should be interpolated. Default value is true.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.JensenCosine","page":"Reference","title":"FLOWFarm.JensenCosine","text":"JensenCosine(alpha)\n\nContainer for parameters related to the Jensen Cosine deficit model\n\nArguments\n\nalpha::Float: parameter controlling the wake deficit decay rate. Default value is 0.1\nbeta::Float: parameter controlling the width of the cosine function. Default value is 20.0 deg., given in radians.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.JensenTopHat","page":"Reference","title":"FLOWFarm.JensenTopHat","text":"JensenTopHat(alpha)\n\nContainer for parameters related to the Jensen Top Hat deficit model\n\nArguments\n\nalpha::Float: parameter controlling the wake spreading rate and deficit decay. Default value is 0.1\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.JiminezYawDeflection","page":"Reference","title":"FLOWFarm.JiminezYawDeflection","text":"JiminezYawDeflection(horizontal_spread_rate)\n\nContainer for parameters related to the Jiminez deflection model\n\nArguments\n\nhorizontal_spread_rate::Float: parameter controlling the wake spreading rate and deficit decay. Default value is 0.1\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.Levelized","page":"Reference","title":"FLOWFarm.Levelized","text":"Levelized(TCC, BOS, FC, FCR, OpEx)\n\nContainer for parameters related to the Levelized Cost of Energy model (NREL 2016 Cost of Wind Energy)\n\nArguments\n\nArguments\n\nTCC::Float: Turbine Capital Cost not including the tower module\nBOS::Float: Balance of System (Costs outside of turbine i.e. operation and maintenance)\nFC::Float: Financial Costs including construction and contingency\nFCR::Float: Fixed Charge Rate\nOpEx::Float: Operational Expenditures\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.LocalTIModelGaussTI","page":"Reference","title":"FLOWFarm.LocalTIModelGaussTI","text":"LocalTIModelGaussTI()\n\nCalculate local turbulence intensity using the model presented in Qian and Ishihara (2018)\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.LocalTIModelMaxTI","page":"Reference","title":"FLOWFarm.LocalTIModelMaxTI","text":"LocalTIModelMaxTI(astar, bstar, k1, k2)\n\nCalculate local turbulence intensity using the model presented in Niayifar and Porte Agel (2015, 2016)\n\nArguments\n\nastar::Float: wake spreading parameter from Bastankhah and Porte-Agel Gaussian wake model\nbstar::Float: wake spreading parameter from Bastankhah and Porte-Agel Gaussian wake model\nk1::Float: slope of k vs TI curve\nk2::Float: vertical offset of k vs TI curve\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.LocalTIModelNoLocalTI","page":"Reference","title":"FLOWFarm.LocalTIModelNoLocalTI","text":"LocalTIModelNoLocalTI()\n\nDon't calculate local turbulence intensity. Ambient TI will be used instead for all points\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.MultiZone","page":"Reference","title":"FLOWFarm.MultiZone","text":"MultiZone(me, ke, MU, aU, bU)\n\nContainer for parameters related to the MultiZone deficit model\n\nArguments\n\nme::Float: parameter controlling general wake expansion. Default value is 0.065\nke::Array{Float}(3): parameters controlling the wake expansion of each zone respectively. Default values are [-0.5 0.22 1.0].\nMU::Array{Float}(3): parameters controlling the wake deficit decay of each zone respectively. Default values are [0.5 1.0 5.5].\naU::Float: parameter impacting the wake deficit decay for a constant wake deflection. Default value is 5.0.\nbU::Float: parameter changing the wake deficit decay under yawed conditions. Default value is 1.66.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.MultizoneDeflection","page":"Reference","title":"FLOWFarm.MultizoneDeflection","text":"MultizoneDeflection(horizontal_spread_rate)\n\nContainer for parameters related to the Jiminez deflection model\n\nArguments\n\nhorizontal_spread_rate::Float: parameter controlling the wake spreading rate and deficit decay. Default value is 0.1\nad::Float:Helps define the horizontal deflection of the wake at 0 deg yaw\nbd::Float:Helps define the horizontal deflection of the wake due to downwind distance at 0 deg yaw\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.NoWakeDeficit","page":"Reference","title":"FLOWFarm.NoWakeDeficit","text":"NoWakeDeficit()\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.NoYawDeflection","page":"Reference","title":"FLOWFarm.NoYawDeflection","text":"NoYawDeflection()\n\nAllows for bypassing deflection calculations.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.PowerLawWindShear","page":"Reference","title":"FLOWFarm.PowerLawWindShear","text":"PowerLawWindShear(shear_exponent, ground_height)\n\nProvides shear exponent and ground height to define wind shear curve. Ground height may be tuned because the power law does not always hold near the ground.\n\nArguments\n\nshear_exponent::Float: defines trajectory of wind shear\nground_height::Float: height of the ground (typically zero)\nshear_order::Bool: when shear should be calculated. Can be \"first\", \"last\", or \"none\"\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.PowerModelConstantCp","page":"Reference","title":"FLOWFarm.PowerModelConstantCp","text":"PowerModelConstantCp(cp)\n\nModels will assume a constant cp value as provided\n\nArguments\n\ncp::Float: constant power coefficient value\n'pp::TI': exponent for adjusting power for wind turbine yaw\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.PowerModelCpPoints","page":"Reference","title":"FLOWFarm.PowerModelCpPoints","text":"PowerModelCpPoints(vel_points, cp_points)\n\nModels will use adjust cp based on cp curve using linear interpolation of provided points\n\nArguments\n\nvel_points::Array{N,Float}: wind speed values in m/s\ncp_points::Array{N,Float}: power coefficient values corresponding to the provided speeds\n'pp::TF': exponent for adjusting power for wind turbine yaw\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.PowerModelPowerCurveCubic","page":"Reference","title":"FLOWFarm.PowerModelPowerCurveCubic","text":"PowerModelPowerCurveCubic()\n\nPower will be calculated based on turbine specifications assuming a cubic power curve. Note that this method is inherently incorrect and should only be used for theoretical purposes or after careful validation.\n\nArguments\n\n'pp::TF': exponent for adjusting power for wind turbine yaw\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.PowerModelPowerPoints","page":"Reference","title":"FLOWFarm.PowerModelPowerPoints","text":"PowerModelPowerPoints(vel_points, cp_points)\n\nModels will use adjust wind turbine power based on power curve using linear interpolation of provided points\n\nArguments\n\nvel_points::Array{N,Float}: wind speed values in m/s\npower_points::Array{N,Float}: power values corresponding to the provided speeds\n'pp::TF': exponent for adjusting power for wind turbine yaw\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.ThrustModelConstantCt","page":"Reference","title":"FLOWFarm.ThrustModelConstantCt","text":"ThrustModelConstantCt(ct::Float)\n\nStores a constant ct value for wake calculations\n\nArguments\n\nct::Float: a constant ct value for computation\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.ThrustModelCtPoints","page":"Reference","title":"FLOWFarm.ThrustModelCtPoints","text":"ThrustModelCtPoints(vel_points, ct_points)\n\nStores the thrust coefficient curve in terms of corresponding velocity and thrust coefficient points. ct and velocity points should be in the same order and ordered from lowest wind speed to highest wind speed.\n\nArguments\n\ninflow_velocity::Float: inflow velocity of the wind turbine\nthrust_model::ThrustModelCtPoints: Struct containing ct and velocity points for ct curve\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.WindFarm","page":"Reference","title":"FLOWFarm.WindFarm","text":"WindFarm(windfarm, windresource, windfarmstates)\n\nStruct defining a wind farm\n\nArguments\n\nturbine_x::Array{Float}(Nturbines): contains windturbine x coordinates in the global reference frame\nturbine_y::Array{Float}(Nturbines): contains windturbine y coordinates in the global reference frame\nturbine_z::Array{Float}(Nturbines): contains windturbine base/z coordinates in the global reference frame\nturbine_definition_ids::Array{Int}(Nturbines): contains integers for each wind turbine specifying its definition\nturbine_definitions::Array{AbstractTurbineDefinition}(Ntypes): contains structs defining each wind turbine definition (design) used in the farm\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.WindFarmModelSet","page":"Reference","title":"FLOWFarm.WindFarmModelSet","text":"WindFarmModelSet(wakedeficitmodel, wake_deflection_model, wake_combination_model, local_ti_model)\n\nContainer for objects defining models to use in wind farm calculations\n\nArguments\n\nwake_defiict_model::AbstractWakeDeficitModel: contains a struct defining the desired wake deficit model\nwake_deflection_model::AbstractWakeDeflectionModel: contains a struct defining the desired wake deflection model\nwake_combination_model::AbstractWakeCombinationModel: contains a struct defining the desired wake combination model\nlocal_ti_model::AbstractTurbulenceIntensityModel: contains a struct defining the desired turbulence intensity model\npoint_velocity_average_factor::Float: factor used to determine how point velocity is averaged across the turbine (3 would result in a cubic mean)\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.boundary_struct","page":"Reference","title":"FLOWFarm.boundary_struct","text":"boundary_struct\n\nStruct defining the boundary constraints\n\nArguments\n\nturbine_x: Vector containing x positions of turbines\nturbine_y: Vector containing y positions of turbines\nboundary_scaling_factor: Single float that scales the constraint\nboundary_function: function that takes the boundary vector and the design variables to update the boundary vector\nboundary_vec: Vector containing the boundary constraints\njacobian: Matrix containing the jacobian of the boundary constraints\nconfig: The ForwardDiff config object if using ForwardDiff for jacboian calculation\nupdate_function: function that takes the design variables x and updates the boundary struct\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.preallocations_struct","page":"Reference","title":"FLOWFarm.preallocations_struct","text":"preallocations_struct\n\nstruct that holds all the preallocated space for AEP calculation with one per thread used\n\nArguments\n\nprealloc_turbine_velocities: Vector containing preallocated space for turbine velocities\nprealloc_turbine_ct: Vector containing preallocated space for turbine ct\nprealloc_turbine_ai: Vector containing preallocated space for turbine ai\nprealloc_turbine_local_ti: Vector containing preallocated space for turbine local ti\nprealloc_wake_deficits: Matrix containing preallocated space for wake deficits\nprealloc_contribution_matrix: Matrix containing preallocated space for contribution matrix\nprealloc_deflections: Matrix containing preallocated space for deflections\nprealloc_sigma_squared: Matrix containing preallocated space for sigma squared\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.spacing_struct","page":"Reference","title":"FLOWFarm.spacing_struct","text":"spacing_struct\n\nStruct defining the spacing constraints\n\nArguments\n\nturbine_x: Vector containing x positions of turbines\nturbine_y: Vector containing y positions of turbines\nconstraint_spacing: Single float that defines the minimum spacing between turbines in meters\nconstraint_scaling: Single float that scales the constraint\nspacing_vec: Vector containing the spacing constraints\njacobian: Matrix containing the jacobian of the spacing constraints\nconfig: The ForwardDiff config object if using ForwardDiff for jacboian calculation\nupdate_function: function that takes the design variables x and updates the spacing struct\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.sparse_AEP_struct_stable_pattern","page":"Reference","title":"FLOWFarm.sparse_AEP_struct_stable_pattern","text":"sparseAEPstructstablepattern\n\nStruct that holds all the necessary variables to calculate the AEP gradient using a stable sparsity pattern\n\nArguments\n\ncaches: vector of SparseDiffTools jacobian caches for each wind state\njacobians: vector of sparse matracies containing jacobians for each wind state\nstate_gradients: 2d array, each row is a state gradient (used for threads)\nturbine_powers: 2d array that holds the powers or each turbine (used for threads)\nadtype: AutoSparseForwardDiff object needed for SparseDiffTools\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.sparse_AEP_struct_unstable_pattern","page":"Reference","title":"FLOWFarm.sparse_AEP_struct_unstable_pattern","text":"sparseAEPstructunstablepattern\n\nStruct that holds all the necessary variables to calculate the AEP gradient using an unstable sparsity pattern\n\nArguments\n\ndeficit_thresholds: Vector of floats that define the deficit thresholds for each wind state\npatterns: 3d array that holds the sparsity patterns for each wind state\nstate_gradients: 2d array, each row is a state gradient (used for threads)\njacobians: Vector of sparse arrays containing jacobians for each wind state\nturbine_powers: 2d array that holds the powers or each turbine (used for threads)\nfarm: WindFarm struct\nold_patterns: 3d array that holds the old sparsity patterns for each wind state\ncolors: 2d array that holds the colors for each wind state\nstate_powers: 1d array that holds the state powers\nchunksize: Chunksize for the AutoSparseForwardDiff object\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.sparse_boundary_struct","page":"Reference","title":"FLOWFarm.sparse_boundary_struct","text":"sparseboundarystruct\n\nStruct that holds all the necessary variables to calculate the boundary constraints using sparse methods\n\nArguments\n\nturbine_x: Vector containing x positions of turbines\nturbine_y: Vector containing y positions of turbines\njacobian: Sparse matrix containing the jacobian of the boundary constraints\nad: AutoSparseForwardDiff object\ncache: SparseJacobianCache object for SparseDiffTools\nboundary_vec: Vector containing the boundary constraints\nboundary_function: Function that calculates the boundary constraints\nupdate_function: Function that updates the boundary struct with the new design variables\nboundary_scaling_factor: Single float that scales the boundary constraint\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.sparse_spacing_struct","page":"Reference","title":"FLOWFarm.sparse_spacing_struct","text":"sparsespacingstruct\n\nStruct that holds all the necessary variables to calculate the spacing constraints using sparse methods\n\nArguments\n\nturbine_x: Vector containing x positions of turbines\nturbine_y: Vector containing y positions of turbines\nconstraint_spacing: Single float that defines the minimum spacing between turbines\nconstraint_scaling: Single float that scales the constraint\nspacing_vec: Vector containing the spacing constraints\njacobian: Sparse matrix containing the jacobian of the spacing constraints\ncache: SparseJacobianCache object for SparseDiffTools\nupdate_function: Function that updates the spacing struct with the new design variables\nrelevant_list: 2d array that holds the relevant turbine pairs for the spacing constraint (column 1 holds the first turbine and column 2 holds the second turbine in the pair)\nad: AutoSparseForwardDiff object\nsafe_design_variables: Vector containing the last set of design variables that satisfy the constraints\nfull_spacing_vec: Vector containing the full spacing constraints of the farm for final evaluation\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.wind_farm_constants_struct","page":"Reference","title":"FLOWFarm.wind_farm_constants_struct","text":"windfarmconstants_struct\n\nstruct that holds all the constants for the wind farm\n\nArguments\n\nturbine_z: Vector containing z positions of ground the turbines sit on\nct_models: Vector containing ct_models for each turbine\ngenerator_efficency: Vector containing the generator efficiency of each turbine\ncut_in_speed: Vector containing the cut in speed of each turbine\ncut_out_speed: Vector containing the cut out speed of each turbine\nrated_speed: Vector containing the rated speed of each turbine\nrated_power: Vector containing the rated power of each turbine\nwind_resource: The windresource struct\npower_models: Vector containing power models of each turbine\nmodel_set: The models_set struct\nrotor_sample_points_y: Vector containing y sample points\nrotor_sample_points_z: Vector containing z sample points\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.wind_farm_struct","page":"Reference","title":"FLOWFarm.wind_farm_struct","text":"windfarmstruct\n\nUnifying struct defining a wind farm and all necessary variables to calculate the AEP\n\nArguments\n\nturbine_x: Vector containing x positions of turbines\nturbine_y: Vector containing y positions of turbines\nhub_height: Vector containing hub heights of each turbines as measured form the ground the turbines sit on\nturbine_yaw: Vector containing yaw angle of each turbine in radians\nrotor_diameter: Vector containing the rotor diameter of each turbine\nresults: DiffResults object to extract AEP when calculating AEP gradient\nconstants: windfarmconstants_struct\nAEP_scale: Scaling factor for the AEP\nideal_AEP: The ideal AEP of the farm\npreallocations: preallocated space\nupdate_function: function that takes the design variables x and updates the farm struct\nAEP_gradient: The gradient of the AEP\nAEP: The AEP of the farm\nconfig: The ForwardDiff config object if using ForwardDiff for AEP gradient calculation, otherwise nothing\nforce_single_thread: Boolean that forces the code to run in a single thread\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.DiscreteCircum","page":"Reference","title":"FLOWFarm.DiscreteCircum","text":"PointsOnCircum(center_x, center_y, r, n = 100)\n\nGiven a circle center, radius, and number of discrete points, returns an array of discrete points along the circle's circumference\n\nArguments\n\ncenter_x::Float64 : cartesian x-coordinate for the center of the circle\ncenter_y::Float64 : cartesian y-coordinate for the center of the circle\nr::Float64 : distance from circle's center to the circumference points\nn::Float64 : defaults to 100, is the number of discrete evenly-spaced points       that will be returned along the circle's circumference\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.GaussianTI-NTuple{8, Any}","page":"Reference","title":"FLOWFarm.GaussianTI","text":"GaussianTI(loc,turbine_x, turbine_y, rotor_diameter, hub_height, turbine_ct,\n    sorted_turbine_index, ambient_ti; div_sigma=2.5, div_ti=1.2)\n\nCalculate local turbulence intensity based on \"On wake modeling, wind-farm gradients and AEP     predictions at the Anholt wind farm\" by Pena Diaz, Alfredo; Hansen, Kurt Schaldemose;     Ott, Søren; van der Laan, Paul ??\n\nArguments\n\nloc::Array{Float,3}: [x,y,z] location of point of interest in wind direction ref. frame\nturbine_x::Array{Float,nTurbines}: turbine wind direction locations in the wind direction   reference frame\nturbine_y::Array{Float,nTurbines}: turbine cross wind locations in the wind direction   reference frame\nrotor_diameter::Array{Float,nTurbines}: rotor diameters of all turbines\nhub_height::Array{Float,nTurbines}: hub heights of all turbines relative to the ground\nturbine_ct::Array{Float,nTurbines}: thrust coefficient of each turbine for the given state\nsorted_turbine_index::Array{Float,nTurbines}: turbine north-south locations in the   global reference frame\nambient_ti::Float: ambient turbulence intensity\ndiv_sigma::Float: ?\ndiv_ti::Float: ?\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.VR_boundary-NTuple{5, Any}","page":"Reference","title":"FLOWFarm.VR_boundary","text":"VR_boundary(bndry_x_clsd, bndry_y_clsd, start_dist, turb_spacing, num_turbs, bndry_seg_length)\n\nUses the Boundary portion of Boundary-Grid variable reduction method place turbines along a closed wind farm boundary and perturb their location with one (1) variable <startdist>.  NOTE: Use of this function assumes prior use of VRbounary_startup(), which ensures the number of turbines placed on the boundary doesn't violate any minimum spacing rules either along the boundary or around corners.\n\nArguments\n\nbndry_x::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndry_y::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\nstart_dist::Float64: the distance (positive or negative) along the boundary       from the first boundary point where the turbines will begin to be placed\nturb_spacing::Float64: the fixed distance along the boundary's edge between       adjacent turbines\n'numturbs::Float64`: the number of turbines to be placed around the boundary.       Note that this function assumes VRbounary_startup() has already been       run so that the user won't attempt to place too many turbines.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.VR_boundary_startup-NTuple{5, Any}","page":"Reference","title":"FLOWFarm.VR_boundary_startup","text":"VR_bounary_startup(bndry_x_clsd, bndry_y_clsd, start_dist, turb_min_spacing, num_turbs)\n\nDetermines if the requested number of turbines can be placed along the closed boundary with spacing and corner constraints. If the requested <num_turbs> is too many, places as many turbines as possible along the boundary, and returns the number of turbines not placed. NOTE: A shortcoming is that the smallest-angled corner limits the spacing of all turbines. in the worst case, a very thin boundary area would prevent any more than one turbine being placed on the boundary, though more would be optimal. Future work would check to make sure this corner (and the length of its adjacent sides) don't actually require limiting the minimum distance between turbines.\n\nArguments\n\nbndry_x::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndry_y::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\nstart_dist::Float64: the distance (positive or negative) along the boundary       from the first boundary point where the turbines will begin to be placed\nturb_min_spacing::Float64: the fixed distance along the boundary's edge between       adjacent turbines\n'numturbs::Float64`: the number of turbines to be placed around the boundary.       Note that this function assumes VRbounary_startup() has already been       run so that the user won't attempt to place too many turbines.\n'bndryseglength::Array{Int}`: an array of the lengths between adjacent       boundary verticies, corresponding to how they appear in bndry_x and _y\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm._ct_to_axial_ind_func-Tuple{Any}","page":"Reference","title":"FLOWFarm._ct_to_axial_ind_func","text":"_ct_to_axial_ind_func(ct)\n\nCalculate axial induction from the thrust coefficient. See Gebraad et. al. 2017 \"Maximization of the Annual Energy Production of Wind Power Plants by Optimization of Layout and Yaw-Based Wake Control\"\n\nArguments\n\nct::Float: thrust coefficient\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm._gauss_yaw_potential_core-NTuple{6, Any}","page":"Reference","title":"FLOWFarm._gauss_yaw_potential_core","text":"_gauss_yaw_potential_core(dt, yaw, ct, as, ti, bs)\n\nHelper function for wakedeficitmodel when using the GaussYaw model. Computes the length of the near wake potential core.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm._gauss_yaw_spread-NTuple{5, Any}","page":"Reference","title":"FLOWFarm._gauss_yaw_spread","text":"_gauss_yaw_spread(dt, k, dx, x0, yaw)\n\nHelper function for wakedeficitmodel when using the GaussYaw model. Computes the standard deviation of the wake.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm._gauss_yaw_spread_interpolated-NTuple{6, Any}","page":"Reference","title":"FLOWFarm._gauss_yaw_spread_interpolated","text":"_gauss_yaw_spread_interpolated(dt, k, dx, x0, yaw)\n\nHelper function for wakedeficitmodel when using the GaussYaw model. Computes the standard deviation of the wake. with an interpolation on the near wake.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm._niayifar_added_ti_function-NTuple{12, Any}","page":"Reference","title":"FLOWFarm._niayifar_added_ti_function","text":"_niayifar_added_ti_function(x, d_dst, d_ust, h_ust, h_dst, ct_ust, kstar_ust, delta_y,\n    ti_amb, ti_ust, ti_dst, ti_area_ratio_in; s=700.0)\n\nMain code for calculating the local turbulence intensity at a turbine using the method of     Niayifar and Porte Agel (2015, 2016).\n\nArguments\n\nx::Float: downstream distance from turbine to point of interest\nd_dst::Float: downstream turbine rotor diameter\nd_ust::Float: upstream turbine rotor diameter\nh_ust::Float: upstream turbine hub height\nh_dst::Float: downstream turbine hub height\nct_ust::Float: upstream turbine thrust coefficient\nkstar_ust::Float: upstream turbine wake expansion rate\ndelta_y::Float: cross wind separation from turbine to point of interest\nti_amb::Float: ambient turbulence intensity\nti_ust::Float: upstream turbine local turbulence intensity\nti_dst::Float: downstream turbine local turbulence intensity\nti_area_ratio_in::Float: current value of TI-area ratio for use in calculatin local TI\ns::Float: smooth max smootheness parameter\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm._remove_out_of_bounds_points-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm._remove_out_of_bounds_points","text":"_remove_perimeter_points!(n; alpha=0.0)\n\nInternal function. Removes points outside or outside and on the border of the rotor-swept     area\n\nArguments\n\ny::AbstractArray: horizontal point locations\nz::AbstractArray: vertical point locations\nuse_perimeter_points::Bool: flag that determines whether or not to include points on the   boundary of the rotor-swept area\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.adjust_for_wind_shear-Tuple{Any, Any, Any, Any, PowerLawWindShear}","page":"Reference","title":"FLOWFarm.adjust_for_wind_shear","text":"adjust_for_wind_shear(locz, reference_velocity, reference_height, ground_height, model::PowerLawWindShear)\n\nUses provided velocity at a given height to estimate the velocity at a different height due to wind shear. Ground height may be tuned because the power law does not always hold near the ground.\n\nArguments\n\nlocz::Float: height of desired velocity\nreference_velocity::Float: known velocity at reference_height\nreference_height::Float: height of known velocity\nground_height::Float: height of the ground (typically zero)\nmodel::AbstractWindShearModel: wind shear model to use for calculations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.boundary_normals_calculator-Tuple{Any}","page":"Reference","title":"FLOWFarm.boundary_normals_calculator","text":"boundary_normals_calculator(boundary_vertices; nboundaries=1)\n\nOutputs the unit vectors perpendicular to each edge of each polygon in a set of polygons, given the Cartesian coordinates for each polygon's vertices.\n\nArguments\n\nboundary_vertices::Array{Float,1} : ragged array of arrays containing all the boundary vertices of each polygon, counterclockwise\nnboundaries::Int : the number of boundaries in the set\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.build_boundary_struct-NTuple{6, Any}","page":"Reference","title":"FLOWFarm.build_boundary_struct","text":"buildboundarystruct\n\nbuildboundarystruct(x,nturbines,nconstraints,scaling,constraintfunction,updatefunction;using_sparsity=true)\n\nArguments\n\nx: Vector containing the desired design variables for optimization\nn_turbines: Number of turbines in the wind farm\nn_constraints: Number of boundary constraints (n_turbines * number of sides of the boundary)\nscaling: The scaling factor for the boundary constraint\nconstraint_function: Function that calculates the boundary constraints\nupdate_function: Function that updates the boundary struct with the new design variables\nusing_sparsity: Boolean to use sparsity in the jacobian calculation (default is true)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.build_relevant_list-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.build_relevant_list","text":"buildrelevantlist(turbinex,turbiney,space,factor)\n\nHelper function that builds the relevant list for the sparse spacing constraints\n\nArguments\n\nturbine_x: Vector containing x positions of turbines\nturbine_y: Vector containing y positions of turbines\nspace: Single float that defines the minimum spacing between turbines\nfactor: Single float that defines the factor of space to be considered relevant\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.build_spacing_struct-NTuple{5, Any}","page":"Reference","title":"FLOWFarm.build_spacing_struct","text":"buildspacingstruct(x,nturbines,space,scale,updatefunction)\n\nfunction to build a spacing_struct\n\nArguments\n\nx: Vector containing the desired design variables for optimization\nn_turbines: Number of turbines in the wind farm\nspace: The minimum spacing between turbines\nscale: The scaling factor for the spacing constraint\nupdate_function: Function that updates the spacing struct with the new design variables\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.build_sparse_spacing_struct-NTuple{6, Any}","page":"Reference","title":"FLOWFarm.build_sparse_spacing_struct","text":"buildsparsespacingstruct(x,turbinex,turbiney,space,scale,updatefunction;firstopt=true,relevantspacing_factor=2)\n\nFunction that builds a sparsespacingstruct\n\nArguments\n\nx: Vector containing the design variables\nturbine_x: Vector containing x positions of turbines\nturbine_y: Vector containing y positions of turbines\nspace: Single float that defines the minimum spacing between turbines\nscale: Single float that scales the constraint\nupdate_function: Function that updates the spacing struct with the new design variables\nfirst_opt: Boolean to determine if this is the first optimization (if true uses no spacing constraints)\nrelevant_spacing_factor: Single float that defines the factor of space to be considered relevant\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.build_stable_sparse_struct-NTuple{17, Any}","page":"Reference","title":"FLOWFarm.build_stable_sparse_struct","text":"buildstablesparsestruct(x,turbinex,turbiney,turbinez,hubheight,turbineyaw,rotordiameter,                 ctmodels,generatorefficiency,cutinspeed,cutoutspeed,ratedspeed,ratedpower,windresource,                 powermodels,modelset,updatefunction;rotorsamplepointsy=[0.0],rotorsamplepointsz=[0.0],                 AEPscale=0.0,optx=false,opty=false,opthub=false,optyaw=false,optdiam=false,tolerance=1E-16,                 forcesingle_thread=false)\n\nFunction that builds a windfarmstruct and a sparseAEPstructstablepattern struct that goes with it\n\nArguments\n\nx: Vector containing the design variables\nturbine_x: Vector containing x positions of turbines\nturbine_y: Vector containing y positions of turbines\nturbine_z: Vector containing z positions of turbines (this is where the base meets the ground)\nhub_height: Vector containing hub heights of turbines\nturbine_yaw: Vector containing yaw angles of turbines\nrotor_diameter: Vector containing rotor diameters of turbines\nct_models: Vector containing ct_models for each turbine\ngenerator_efficiency: Vector containing generator efficiencies for each turbine\ncut_in_speed: Vector containing cut in speeds for each turbine\ncut_out_speed: Vector containing cut out speeds for each turbine\nrated_speed: Vector containing rated speeds for each turbine\nrated_power: Vector containing rated powers for each turbine\nwind_resource: The DiscretizedWindResource struct\npower_models: Vector containing power models for each turbine\nmodel_set: The WindFarmModelSet for the wind farm\nupdate_function: Function that updates the wind farm struct with the new design variables\nrotor_sample_points_y: Vector containing the y positions of the rotor sample points\nrotor_sample_points_z: Vector containing the z positions of the rotor sample points\nAEP_scale: Single float that scales the AEP, if 0.0 will be set to 1.0/ideal_AEP\ninput_type: default is nothing and will be set to the type of x, if \"ForwardDiff\" then the input type will be set to ForwardDiff.dual\nopt_x: Boolean to optimize x positions of turbines\nopt_y: Boolean to optimize y positions of turbines\nopt_hub: Boolean to optimize hub heights of turbines\nopt_yaw: Boolean to optimize yaw angles of turbines\nopt_diam: Boolean to optimize rotor diameters of turbines\ntolerance: Single float that defines the tolerance for the jacobian pattern (default is 1E-16), set to 0.0 to use traditional sparsity\nforce_single_thread: Boolean to force single thread calculation\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.build_stable_sparse_struct-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.build_stable_sparse_struct","text":"buildstablesparse_struct(x,farm;tolerance=1E-16)\n\nHelper function that builds a sparseAEPstructstablepattern struct\n\nArguments\n\nx: Vector containing the  design variables\nfarm: WindFarm struct\ntolerance: Single float that defines the tolerance for the jacobian pattern\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.build_unstable_sparse_struct-NTuple{17, Any}","page":"Reference","title":"FLOWFarm.build_unstable_sparse_struct","text":"buildunstablesparsestruct(x,turbinex,turbiney,turbinez,hubheight,turbineyaw,rotordiameter,                 ctmodels,generatorefficiency,cutinspeed,cutoutspeed,ratedspeed,ratedpower,windresource,                 powermodels,modelset,updatefunction;rotorsamplepointsy=[0.0],rotorsamplepointsz=[0.0],                 AEPscale=0.0,optx=false,opty=false,opthub=false,optyaw=false,optdiam=false,tolerance=1E-16,                 forcesingle_thread=false)\n\nFunction that builds a windfarmstruct and a sparseAEPstructunstablepattern struct\n\nArguments\n\nx: Vector containing the  design variables\nturbine_x: Vector containing x positions of turbines\nturbine_y: Vector containing y positions of turbines\nturbine_z: Vector containing z positions of turbines (this is where the base meets the ground)\nhub_height: Vector containing hub heights of turbines\nturbine_yaw: Vector containing yaw angles of turbines\nrotor_diameter: Vector containing rotor diameters of turbines\nct_models: Vector containing ct_models for each turbine\ngenerator_efficiency: Vector containing generator efficiencies for each turbine\ncut_in_speed: Vector containing cut in speeds for each turbine\ncut_out_speed: Vector containing cut out speeds for each turbine\nrated_speed: Vector containing rated speeds for each turbine\nrated_power: Vector containing rated powers for each turbine\nwind_resource: The DiscretizedWindResource struct\npower_models: Vector containing power models for each turbine\nmodel_set: The WindFarmModelSet for the wind farm\nupdate_function: Function that updates the wind farm struct with the new design variables\nrotor_sample_points_y: Vector containing the y positions of the rotor sample points\nrotor_sample_points_z: Vector containing the z positions of the rotor sample points\nAEP_scale: Single float that scales the AEP, if 0.0 will be set to 1.0/ideal_AEP\ninput_type: default is nothing and will be set to the type of x, if \"ForwardDiff\" then the input type will be set to ForwardDiff.dual\nopt_x: Boolean to optimize x positions of turbines\nopt_y: Boolean to optimize y positions of turbines\nopt_hub: Boolean to optimize hub heights of turbines\nopt_yaw: Boolean to optimize yaw angles of turbines\nopt_diam: Boolean to optimize rotor diameters of turbines\ntolerance: Single float that defines the tolerance for the jacobian pattern (default is 1E-16), set to 0.0 to use traditional sparsity\nforce_single_thread: Boolean to force single thread calculation\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.build_unstable_sparse_struct-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm.build_unstable_sparse_struct","text":"buildunstablesparsestruct(x,farm,farmforwarddiff;tolerance=1E-16)\n\nHelper function that builds a sparseAEPstructunstablepattern struct\n\nArguments\n\nx: Vector containing the  design variables\nfarm: WindFarm struct\nfarm_forwarddiff: WindFarm struct with ForwardDiff input type for deficit tolerance calculation\ntolerance: Single float that defines the tolerance for the jacobian pattern\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.build_wind_farm_struct-NTuple{17, Any}","page":"Reference","title":"FLOWFarm.build_wind_farm_struct","text":"buildwindfarmstruct(x,turbinex,turbiney,turbinez,hubheight,turbineyaw,rotordiameter,             ctmodels,generatorefficiency,cutinspeed,cutoutspeed,ratedspeed,ratedpower,windresource,             powermodels,modelset,updatefunction;rotorsamplepointsy=[0.0],rotorsamplepointsz=[0.0],             AEPscale=0.0,inputtype=nothing,optx=false,opty=false,opthub=false,optyaw=false,optdiam=false,             forcesinglethread=false)\n\nfunction to build a windfarmstruct\n\nArguments\n\nx: Vector containing the desired design variables for optimization (if any)\nturbine_x: Vector containing x positions of turbines\nturbine_y: Vector containing y positions of turbines\nturbine_z: Vector containing z positions of turbines (this is where the base meets the ground)\nhub_height: Vector containing hub heights of turbines\nturbine_yaw: Vector containing yaw angles of turbines\nrotor_diameter: Vector containing rotor diameters of turbines\nct_models: Vector containing ct_models for each turbine\ngenerator_efficiency: Vector containing generator efficiencies for each turbine\ncut_in_speed: Vector containing cut in speeds for each turbine\ncut_out_speed: Vector containing cut out speeds for each turbine\nrated_speed: Vector containing rated speeds for each turbine\nrated_power: Vector containing rated powers for each turbine\nwind_resource: The DiscretizedWindResource struct\npower_models: Vector containing power models for each turbine\nmodel_set: The WindFarmModelSet for the wind farm\nupdate_function: Function that updates the wind farm struct with the new design variables\nrotor_sample_points_y: Vector containing the y positions of the rotor sample points\nrotor_sample_points_z: Vector containing the z positions of the rotor sample points\nAEP_scale: Single float that scales the AEP, if 0.0 will be set to 1.0/ideal_AEP\ninput_type: default is nothing and will be set to the type of x, if \"ForwardDiff\" then the input type will be set to ForwardDiff.dual\nopt_x: Boolean to optimize x positions of turbines\nopt_y: Boolean to optimize y positions of turbines\nopt_hub: Boolean to optimize hub heights of turbines\nopt_yaw: Boolean to optimize yaw angles of turbines\nopt_diam: Boolean to optimize rotor diameters of turbines\nforce_single_thread: Boolean to force single thread calculation\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calcMinorAngle","page":"Reference","title":"FLOWFarm.calcMinorAngle","text":"calcMinorAngle(bndry_x, bndry_y, bndry_z=[0,0,0])\n\nGiven three points in space, calculates the magnitude of the non-reflex angle formed at the center point. Created to be used in VRbounarystartup()\n\nArguments\n\nbndry_x::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndry_y::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\nbndry_z::Array{Float,1} : 1-D array of z-coordinates for the vertices       around a singlar closed boundary. Default to [0,0,0] for X-Y plane\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.calcSmallestAngle-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.calcSmallestAngle","text":"calcSmallestAngle(bndry_x_clsd, bndry_y_clsd)\n\nGiven a 1-D closed array of boundary verticies (with first point repeated at the end) it determines the smallest non-reflex angle created by any three consecutive verticies along the boundary. Created to be used in VRbounarystartup()\n\nArguments\n\nbndry_x::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndry_y::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calc_moment_stress","page":"Reference","title":"FLOWFarm.calc_moment_stress","text":"calc_moment_stress(mx,my,dx,dy,Rcyl=1.771,tcyl=0.06)\n\nCalculates stresses from bending moments on a hollow cylinder\n\nArguments\n\nmx::Float: x moment\nmy::Float: y moment\ndx::Float: x distance to the location of interest\ndy::Float: y distance to the location of interest\n\nKeyword Arguments\n\nRcyl::Float: radius of the cylinder\ntcyl::Float: thickenss of the cylinder\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.calculate_aep!-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.calculate_aep!","text":"calculate_aep!\n\nfunction calculate_aep!(farm,x)\n\nArguments\n\nfarm: The windfarmstruct\nx: Vector containing the design variables\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_aep-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}","page":"Reference","title":"FLOWFarm.calculate_aep","text":"calculate_aep(turbine_x, turbine_y, turbine_z, rotor_diameter,\nhub_height, turbine_yaw, ct_model, generator_efficiency, cut_in_speed,\ncut_out_speed, rated_speed, rated_power, wind_resource, power_models::Array{AbstractPowerModel}, model_set::AbstractModelSet;\nrotor_sample_points_y=[0.0], rotor_sample_points_z=[0.0], hours_per_year=365.25*24.0)\n\nCalculate wind farm AEP\n\nArguments\n\nturbine_x::Array{Float,nTurbines}: turbine east-west locations in the global   reference frame\nturbine_y::Array{Float,nTurbines}: turbine north-south locations in the global   reference frame\nturbine_z::Array{Float,nTurbines}: turbine base height in the global reference frame\nrotor_diameter::Array{Float,nTurbines}\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in   radians\nct_model::AbstractThrustCoefficientModel: defines how the thrust coefficient changes   with state etc\ngenerator_efficiency::Array{Float,nTurbines}\ncut_in_speed::Array{Float,nTurbines}\ncut_out_speed::Array{Float,nTurbines}\nrated_speed::Array{Float,nTurbines}\nrated_power::Array{Float,nTurbines}\nwind_resource::DiscretizedWindResource: wind resource discreption (directions, speeds,   frequencies, etc)\npower_model::Array{): elements of array should be sub types of AbstractPowerModel\nmodel_set::AbstractModelSet: defines wake-realated models to be used in analysis\nrotor_sample_points_y::Array{TF,N}: horizontal wind location of points to sample across   the rotor swept area when calculating the effective wind speed for the wind turbine.   Points are centered at the hub (0,0) and scaled by the radius (1=tip of blades)\nrotor_sample_points_z::Array{TF,N}: vertical wind location of points to sample across the   rotor swept area when calculating the effective wind speed for the wind turbine. Points   are centered at the hub (0,0) and scaled by the radius (1=tip of blades)\nhours_per_year::Float: hours per year (averaged for leap year by default)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_aep_gradient!-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.calculate_aep_gradient!","text":"calculateaepgradient!(farm,x)\n\nfunction to calculate the AEP and its gradient for the wind farm, results are stored within the windfarmstruct and take into account the scaling factor\n\nArguments\n\nfarm: The windfarmstruct\nx: Vector containing the design variables\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_aep_gradient!-Union{Tuple{T}, Tuple{Any, Any, T}} where T<:FLOWFarm.AbstractSparseMethod","page":"Reference","title":"FLOWFarm.calculate_aep_gradient!","text":"calculateaepgradient!(farm,x,sparse_struct::T)\n\nfunction to calculate the AEP and its gradient for the wind farm using sparse methods\n\nArguments\n\nfarm: The windfarmstruct\nx: Vector containing the design variables\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_aep_gradient!-Union{Tuple{T}, Tuple{Any, Any, T}} where T<:FLOWFarm.StableSparseMethod","page":"Reference","title":"FLOWFarm.calculate_aep_gradient!","text":"calculateaepgradient!(farm,x,sparse_struct::T)\n\nFunction that calculates the AEP gradient using a stable sparsity pattern\n\nArguments\n\nfarm: WindFarm struct\nx: Vector containing the scaled design variables\nsparse_struct: sparseAEPstructstablepattern struct\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_aep_gradient!-Union{Tuple{T}, Tuple{Any, Any, T}} where T<:FLOWFarm.UnstableSparseMethod","page":"Reference","title":"FLOWFarm.calculate_aep_gradient!","text":"calculateaepgradient!(farm,x,sparse_struct::T)\n\nFunction that calculates the AEP gradient using an unstable sparsity pattern\n\nArguments\n\nfarm: WindFarm struct\nx: Vector containing the scaled design variables\nsparse_struct: sparseAEPstructunstablepattern struct\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_boundary!-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm.calculate_boundary!","text":"calculateboundary!(boundaryvec,x,boundary_struct)\n\nfunction to calculate the boundary constraints for the wind farm\n\nArguments\n\nboundary_vec: Vector containing the boundary constraints (just us boundarystruct.boundaryvec)\nx: Vector containing the design variables\nboundary_struct: The boundary_struct\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_boundary_jacobian!-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.calculate_boundary_jacobian!","text":"calculateboundaryjacobian!(boundary_struct,x)\n\nfunction to calculate the boundary constraints and the jacobian for the wind farm, results stored in boundary_struct\n\nArguments\n\nboundary_struct: The boundary_struct\nx: Vector containing the design variables\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_boundary_jacobian!-Union{Tuple{T}, Tuple{T, Any}} where T<:FLOWFarm.AbstractSparseMethod","page":"Reference","title":"FLOWFarm.calculate_boundary_jacobian!","text":"calculateboundaryjacobian!(boundary_struct::T,x)\n\nFunction that builds a sparseboundarystruct\n\nArguments\n\nboundary_struct: sparseboundarystruct\nx: Vector containing the design variables\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_ct-Tuple{Any, ThrustModelConstantCt}","page":"Reference","title":"FLOWFarm.calculate_ct","text":"calculate_ct(model::ThrustModelConstantCt)\n\nCalculate the thrust coefficient for a wind turbine based on a pre-determined constant ct\n\nArguments\n\ninflow_velocity::Float: inflow velocity of the wind turbine (unused for const. ct)\nthrust_model::ThrustModelConstantCt: struct containing a constant ct value for computation\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_ct-Tuple{Any, ThrustModelCtPoints}","page":"Reference","title":"FLOWFarm.calculate_ct","text":"calculate_ct(inflow_velocity, thrust_model::ThrustModelCtPoints)\n\nCalculate the thrust coefficient for a wind turbine based on a pre-determined ct curve\n    with linear interpolation.\n\nArguments\n\ninflow_velocity::Float: inflow velocity of the wind turbine\nthrust_model::ThrustModelCtPoints: Struct containing ct and velocity points for ct curve\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_flow_field-Tuple{Any, Any, Any, FLOWFarm.AbstractModelSet, Vararg{Any, 12}}","page":"Reference","title":"FLOWFarm.calculate_flow_field","text":"calculateflowfield(xrange, yrange, zrange, modelset::AbstractModelSet, turbinex,     turbiney, turbinez, turbineyaw, turbinect, turbineai, rotordiameter, hubheight,     turbinelocalti, sortedturbineindex, wtvelocities, windresource; windfarmstate_id=1)\n\nGenerates a flow field for a given state and cross section\n\nArguments\n\nxrange::Range: range defining east-west locations to sample in global reference frame\nyrange::Range: range defining north-west locations to sample in global reference frame\nzrange::Range: range defining vertical locations to sample in global reference frame\nmodel_set::AbstractModelSet: defines wake-realated models to be used in analysis\nturbine_x::Array{TF,nTurbines}: turbine east-west locations in the global   reference frame\nturbine_y::Array{TF,nTurbines}: turbine north-south locations in the global   reference frame\nturbine_z::Array{TF,nTurbines}: turbine base height in the global reference frame\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in   radians\nturbine_ct::Array{TF,nTurbines}: thrust coefficient of each turbine for the given state\nturbine_ai::Array{TF,nTurbines}: turbine axial induction for the given state\nrotor_diameter::Array{TF,nTurbines}: turbine rotor diameters\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_local_ti::Array{TF,nTurbines}: turbine local turbulence intensity for   the given state\nsorted_turbine_index::Array{TF,nTurbines}: turbine north-south locations in the   global reference frame\nwtvelocities::Array{TF,nTurbines}: effective inflow wind speed for given state\nwind_resource::DiscretizedWindResource: wind resource discreption (directions, speeds,   frequencies, etc)\nwind_farm_state_id::Int: index to correct state to use from wind resource provided.   Defaults to 1\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_ideal_aep-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}","page":"Reference","title":"FLOWFarm.calculate_ideal_aep","text":"calculate_aep(turbine_x, turbine_y, turbine_z, rotor_diameter,\nhub_height, turbine_yaw, ct_model, generator_efficiency, cut_in_speed,\ncut_out_speed, rated_speed, rated_power, wind_resource, power_models::Array{AbstractPowerModel}, model_set::AbstractModelSet;\nrotor_sample_points_y=[0.0], rotor_sample_points_z=[0.0], hours_per_year=365.25*24.0)\n\nCalculate ideal wind farm AEP (AEP with no wake loss)\n\nArguments\n\nturbine_x::Array{Float,nTurbines}: turbine east-west locations in the global   reference frame\nturbine_y::Array{Float,nTurbines}: turbine north-south locations in the global   reference frame\nturbine_z::Array{Float,nTurbines}: turbine base height in the global reference frame\nrotor_diameter::Array{Float,nTurbines}\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in   radians\nct_model::AbstractThrustCoefficientModel: defines how the thrust coefficient changes   with state etc\ngenerator_efficiency::Array{Float,nTurbines}\ncut_in_speed::Array{Float,nTurbines}\ncut_out_speed::Array{Float,nTurbines}\nrated_speed::Array{Float,nTurbines}\nrated_power::Array{Float,nTurbines}\nwind_resource::DiscretizedWindResource: wind resource discreption (directions, speeds,   frequencies, etc)\npower_model::Array{): elements of array should be sub types of AbstractPowerModel\nmodel_set::AbstractModelSet: defines wake-realated models to be used in analysis\nrotor_sample_points_y::Array{TF,N}: horizontal wind location of points to sample across   the rotor swept area when calculating the effective wind speed for the wind turbine.   Points are centered at the hub (0,0) and scaled by the radius (1=tip of blades)\nrotor_sample_points_z::Array{TF,N}: vertical wind location of points to sample across the   rotor swept area when calculating the effective wind speed for the wind turbine. Points   are centered at the hub (0,0) and scaled by the radius (1=tip of blades)\nhours_per_year::Float: hours per year (averaged for leap year by default)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_local_ti-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, LocalTIModelGaussTI}","page":"Reference","title":"FLOWFarm.calculate_local_ti","text":"calculate_local_ti(turbine_x, turbine_y, ambient_ti, rotor_diameter, hub_height, turbine_yaw, turbine_local_ti, sorted_turbine_index,\nturbine_inflow_velcities, turbine_ct, ti_model::LocalTIModelGaussTI; turbine_id=1, tol=1E-6)\n\nReturns local turbulence intensity calculated using methods in Qian 2018 from the Journal of Wind Energy https://doi.org/10.1016/j.jweia.2018.04.010 with modification to account for yaw coming from Qian 2018 from Energies doi:10.3390/en11030665\n\nArguments\n\nturbine_x::Array{Float,nTurbines}: turbine wind direction locations in the wind direction   reference frame\nturbine_y::Array{Float,nTurbines}: turbine cross wind locations in the wind direction   reference frame\nambient_ti::Float: ambient turbulence intensity\nrotor_diameter::Array{Float,nTurbines}: rotor diameters of all turbines\nhub_height::Array{Float,nTurbines}: hub heights of all turbines relative to the ground\nturbine_yaw::Array{Float,nTurbines}: yaw of all turbines for the current wind state in radians\nturbine_local_ti::Array{Float,nTurbines}: local turbulence intensity of all turbines for the current wind state`\nsorted_turbine_index::Array{Float,nTurbines}: turbine north-south locations in the   global reference frame\nturbine_inflow_velcities::Array{Float,nTurbines}: effective inflow wind speed at each turbine for given state\nturbine_ct::Array{Float,nTurbines}: thrust coefficient of each turbine for the given state\nti_model::LocalTIModelGaussTI: contains a struct defining the desired turbulence intensity model\nturbine_id::Int: index of wind turbine of interest. Provide 1 as default.\ntol::Float: How far upstream a turbine should be before being included in TI calculations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_local_ti-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, LocalTIModelMaxTI}","page":"Reference","title":"FLOWFarm.calculate_local_ti","text":"calculate_local_ti(turbine_x, turbine_y, ambient_ti, rotor_diameter, hub_height, turbine_yaw, turbine_local_ti, sorted_turbine_index,\nturbine_inflow_velcities, turbine_ct, ti_model::LocalTIModelMaxTI; turbine_id=1, tol=1E-6)\n\nReturns local turbulence intensity calculated using Niayifar and Porte Agel 2015, 2016 using smooth max on area TI ratio\n\nArguments\n\nturbine_x::Array{Float,nTurbines}: turbine wind direction locations in the wind direction   reference frame\nturbine_y::Array{Float,nTurbines}: turbine cross wind locations in the wind direction   reference frame\nambient_ti::Float: ambient turbulence intensity\nrotor_diameter::Array{Float,nTurbines}: rotor diameters of all turbines\nhub_height::Array{Float,nTurbines}: hub heights of all turbines relative to the ground\nturbine_yaw::Array{Float,nTurbines}: yaw of all turbines for the current wind state in radians\nturbine_local_ti::Array{Float,nTurbines}: local turbulence intensity of all turbines for the current wind state`\nsorted_turbine_index::Array{Float,nTurbines}: turbine north-south locations in the   global reference frame\nturbine_inflow_velcities::Array{Float,nTurbines}: effective inflow wind speed at each turbine for given state\nturbine_ct::Array{Float,nTurbines}: thrust coefficient of each turbine for the given state\nti_model::LocalTIModelMaxTI: contains a struct defining the desired turbulence intensity model, no local TI in this case\nturbine_id::Int: index of wind turbine of interest. Provide 1 as default.\ntol::Float: How far upstream a turbine should be before being included in TI calculations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_local_ti-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, LocalTIModelNoLocalTI}","page":"Reference","title":"FLOWFarm.calculate_local_ti","text":"calculate_local_ti(turbine_x, turbine_y, ambient_ti, rotor_diameter, hub_height, turbine_yaw, turbine_local_ti, sorted_turbine_index,\nturbine_inflow_velcities, turbine_ct, ti_model::LocalTIModelNoLocalTI; turbine_id=1, tol=1E-6)\n\nReturns ambient turbulence intesity value whenever local turbulence intensity is requestesd\n\nArguments\n\nturbine_x::Array{Float,nTurbines}: turbine wind direction locations in the wind direction   reference frame\nturbine_y::Array{Float,nTurbines}: turbine cross wind locations in the wind direction   reference frame\nambient_ti::Float: ambient turbulence intensity\nrotor_diameter::Array{Float,nTurbines}: rotor diameters of all turbines\nhub_height::Array{Float,nTurbines}: hub heights of all turbines relative to the ground\nturbine_yaw::Array{Float,nTurbines}: yaw of all turbines for the current wind state in radians\nturbine_local_ti::Array{Float,nTurbines}: local turbulence intensity of all turbines for the current wind state`\nsorted_turbine_index::Array{Float,nTurbines}: turbine north-south locations in the   global reference frame\nturbine_inflow_velcities::Array{Float,nTurbines}: effective inflow wind speed at each turbine for given state\nturbine_ct::Array{Float,nTurbines}: thrust coefficient of each turbine for the given state\nti_model::LocalTIModelNoLocalTI: contains a struct defining the desired turbulence intensity model, no local TI in this case\nturbine_id::Int: index of wind turbine of interest. Provide 1 as default.\ntol::Float: How far upstream a turbine should be before being included in TI calculations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, PowerModelConstantCp}","page":"Reference","title":"FLOWFarm.calculate_power","text":"calculate_power(generator_efficiency, air_density, rotor_area, wt_velocity, power_model)\n\nCalculate the power for a wind turbine based on standard theory for region 2 using a constant cp\n\nArguments\n\ngenerator_efficiency::Float: Efficiency of the turbine generator\nair_density::Float: Air density\nrotor_area::Float: Rotor-swept area of the wind turbine\nwt_velocity::Float: Inflow velocity to the wind turbine\ncut_in_speed::Float: cut in speed of the wind turbine\nrated_speed::Float: rated speed of the wind turbine\ncut_out_speed::Float: cut out speed of the wind turbine\nrated_power::Float: rated power of the wind turbine\npower_model::PowerModelConstantCp: Struct containing the cp value to be used in region 2\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, PowerModelCpPoints}","page":"Reference","title":"FLOWFarm.calculate_power","text":"calculate_power(generator_efficiency, air_density, rotor_area, wt_velocity, cut_in_speed, rated_speed, cut_out_speed, rated_power, power_model)\n\nCalculate the power for a wind turbine based on a cp curve with linear interpolation\n\nArguments\n\ngenerator_efficiency::Float: Efficiency of the turbine generator\nair_density::Float: Air density\nrotor_area::Float: Rotor-swept area of the wind turbine\nwt_velocity::Float: Inflow velocity to the wind turbine\ncut_in_speed::Float: cut in speed of the wind turbine\nrated_speed::Float: rated speed of the wind turbine\ncut_out_speed::Float: cut out speed of the wind turbine\nrated_power::Float: rated power of the wind turbine\npower_model::PowerModelCpPoints: Struct containing the velocity and cp values defining the cp curve\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, PowerModelPowerCurveCubic}","page":"Reference","title":"FLOWFarm.calculate_power","text":"calculate_power(generator_efficiency, air_density, rotor_area, wt_velocity, cut_in_speed, rated_speed, cut_out_speed, rated_power, power_model)\n\nCalculates wind turbine power using a cubic estimation based on turbine specifications     as defined in https://github.com/byuflowlab/iea37-wflo-casestudies/blob/master/cs3-4/iea37-cs3-announcement.pdf\n\nArguments\n\ngenerator_efficiency::Float: Efficiency of the turbine generator\nair_density::Float: Air density\nrotor_area::Float: Rotor-swept area of the wind turbine\nwt_velocity::Float: Inflow velocity to the wind turbine\ncut_in_speed::Float: cut in speed of the wind turbine\nrated_speed::Float: rated speed of the wind turbine\ncut_out_speed::Float: cut out speed of the wind turbine\nrated_power::Float: rated power of the wind turbine\npower_model::PowerModelPowerCurveCubic: Empty struct\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, PowerModelPowerPoints}","page":"Reference","title":"FLOWFarm.calculate_power","text":"calculate_power(generator_efficiency, air_density, rotor_area, wt_velocity, cut_in_speed, rated_speed, cut_out_speed, rated_power, power_model)\n\nCalculate the power for a wind turbine based on a pre-determined power curve with linear     interpolation\n\nArguments\n\ngenerator_efficiency::Float: Efficiency of the turbine generator\nair_density::Float: Air density\nrotor_area::Float: Rotor-swept area of the wind turbine\nwt_velocity::Float: Inflow velocity to the wind turbine\ncut_in_speed::Float: cut in speed of the wind turbine\nrated_speed::Float: rated speed of the wind turbine\ncut_out_speed::Float: cut out speed of the wind turbine\nrated_power::Float: rated power of the wind turbine\npower_model::PowerModelPowerPoints: Struct containing the velocity and power values   defining the power curve\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_power_from_cp-NTuple{6, Any}","page":"Reference","title":"FLOWFarm.calculate_power_from_cp","text":"calculate_power_from_cp(generator_efficiency, air_density, rotor_area, cp, wt_velocity)\n\nCalculate the power for a wind turbine based on standard theory for region 2\n\nArguments\n\ngenerator_efficiency::Float: Efficiency of the turbine generator\nair_density::Float: Air density\nrotor_area::Float: Rotor-swept area of the wind turbine\ncp::Float: Power coefficient of the wind turbine\nwt_velocity::Float: Inflow velocity to the wind turbine\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_spacing!-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm.calculate_spacing!","text":"calculatespacing!(spacingvec,x,spacing_struct)\n\nfunction to calculate the spacing constraints for the wind farm\n\nArguments\n\nspacing_vec: Vector containing the spacing constraints (just us spacingstruct.spacingvec)\nx: Vector containing the design variables\nspacing_struct: The spacing_struct\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_spacing!-Union{Tuple{T}, Tuple{Any, Any, T}} where T<:FLOWFarm.AbstractSparseMethod","page":"Reference","title":"FLOWFarm.calculate_spacing!","text":"buildspacingstruct(x,nturbines,space,scale,updatefunction)\n\nCalculates the spacing constraints using sparse methods\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_spacing_jacobian!-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.calculate_spacing_jacobian!","text":"calculatespacingjacobian!(spacing_struct,x)\n\nfunction to calculate the spacing constraints and the jacobian for the wind farm, results stored in spacing_struct\n\nArguments\n\nspacing_struct: The spacing_struct\nx: Vector containing the design variables\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_spacing_jacobian!-Union{Tuple{T}, Tuple{T, Any}} where T<:FLOWFarm.AbstractSparseMethod","page":"Reference","title":"FLOWFarm.calculate_spacing_jacobian!","text":"calculatespacingjacobian!(spacing_struct,x)\n\nFunction that calculates the spacing constraints jacobian using sparse methods\n\nArguments\n\nspacing_struct: sparsespacingstruct\nx: Vector containing the design variables\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_state_aeps-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}","page":"Reference","title":"FLOWFarm.calculate_state_aeps","text":"calculate_state_aeps(turbine_x, turbine_y, turbine_z, rotor_diameter,\nhub_height, turbine_yaw, ct_model, generator_efficiency, cut_in_speed,\ncut_out_speed, rated_speed, rated_power, wind_resource, power_models::Array{AbstractPowerModel}, model_set::AbstractModelSet;\nrotor_sample_points_y=[0.0], rotor_sample_points_z=[0.0])\n\nCalculate AEP for each requested state respectively\n\nArguments\n\nturbine_x::Array{Float,nTurbines}: turbine east-west locations in the global   reference frame\nturbine_y::Array{Float,nTurbines}: turbine north-south locations in the global   reference frame\nturbine_z::Array{Float,nTurbines}: turbine base height in the global reference frame\nrotor_diameter::Array{Float,nTurbines}\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in   radians\nct_model::AbstractThrustCoefficientModel: defines how the thrust coefficient changes   with state etc\ngenerator_efficiency::Array{Float,nTurbines}\ncut_in_speed::Array{Float,nTurbines}\ncut_out_speed::Array{Float,nTurbines}\nrated_speed::Array{Float,nTurbines}\nrated_power::Array{Float,nTurbines}\nwind_resource::DiscretizedWindResource: wind resource discreption (directions, speeds,   frequencies, etc)\npower_model::Array{nTurbines}: elemenst of array should be sub-types of AbstractPowerModel\nmodel_set::AbstractModelSet: defines wake-realated models to be used in analysis\nrotorsamplepoints_y::Array{TF,N}`: horizontal wind location of points to sample across   the rotor swept area when calculating the effective wind speed for the wind turbine.   Points are centered at the hub (0,0) and scaled by the radius (1=tip of blades)\nrotorsamplepoints_z::Array{TF,N}`: vertical wind location of points to sample across the   rotor swept area when calculating the effective wind speed for the wind turbine. Points   are centered at the hub (0,0) and scaled by the radius (1=tip of blades)\nhours_per_year::Float: hours per year (averaged for leap year by default)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_state_turbine_powers-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}","page":"Reference","title":"FLOWFarm.calculate_state_turbine_powers","text":"calculate_state_turbine_powers(turbine_x, turbine_y, turbine_z, rotor_diameter,\nhub_height, turbine_yaw, ct_model, generator_efficiency, cut_in_speed,\ncut_out_speed, rated_speed, rated_power, wind_resource, power_models, model_set::AbstractModelSet;\nrotor_sample_points_y=[0.0], rotor_sample_points_z=[0.0])\n\nCalculate power for each turbine for all states respectively\n\nArguments\n\nturbine_x::Array{Float,nTurbines}: turbine east-west locations in the global   reference frame\nturbine_y::Array{Float,nTurbines}: turbine north-south locations in the global   reference frame\nturbine_z::Array{Float,nTurbines}: turbine base height in the global reference frame\nrotor_diameter::Array{Float,nTurbines}\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in   radians\nct_model::AbstractThrustCoefficientModel: defines how the thrust coefficient changes   with state etc\ngenerator_efficiency::Array{Float,nTurbines}\ncut_in_speed::Array{Float,nTurbines}\ncut_out_speed::Array{Float,nTurbines}\nrated_speed::Array{Float,nTurbines}\nrated_power::Array{Float,nTurbines}\nwind_resource::DiscretizedWindResource: wind resource discreption (directions, speeds,   frequencies, etc)\npower_models::Array{nTurbines}: elemenst of array should be sub-types of AbstractPowerModel\nmodel_set::AbstractModelSet: defines wake-realated models to be used in analysis\nrotorsamplepoints_y::Array{TF,N}`: horizontal wind location of points to sample across   the rotor swept area when calculating the effective wind speed for the wind turbine.   Points are centered at the hub (0,0) and scaled by the radius (1=tip of blades)\nrotorsamplepoints_z::Array{TF,N}`: vertical wind location of points to sample across the   rotor swept area when calculating the effective wind speed for the wind turbine. Points   are centered at the hub (0,0) and scaled by the radius (1=tip of blades)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_threshold-NTuple{6, Any}","page":"Reference","title":"FLOWFarm.calculate_threshold","text":"calculatethreshold(x,farmforwarddiff,farm,tolerance,pow,stateid;preallocid=1,lock=nothing)\n\nHelper function that calculates the deficit threshold for a single wind state\n\nArguments\n\nx: Vector containing the design variables\nfarm_forwarddiff: WindFarm struct with ForwardDiff input type for deficit tolerance calculation\nfarm: WindFarm struct\ntolerance: Single float that defines the tolerance for the jacobian pattern\npow: 1d array that holds the powers or each turbine\nstate_id: Wind state id\nprealloc_id: Preallocation id (to select the correct preallocated memory inside the wind farm struct)\nlock: SpinLock object to lock the farm struct for multithreadeding\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_thresholds!-NTuple{8, Any}","page":"Reference","title":"FLOWFarm.calculate_thresholds!","text":"calculatethresholds!(jacobians,thresholds,x,farmforwarddiff,farm,tolerance,pow,n_states)\n\nHelper function that calculates the thresholds for each wind state\n\nArguments\n\njacobians: Vector of sparse arrays holding jacobians\nthresholds: Vector of floats that define the deficit thresholds for each wind state\nx: Vector containing the  design variables\nfarm_forwarddiff: WindFarm struct with ForwardDiff input type for deficit tolerance calculation\nfarm: WindFarm struct\ntolerance: Single float that defines the tolerance for the jacobian pattern\npow: 2d array that holds the powers or each turbine (used for threads)\nn_states: Number of wind states\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_turbine_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractPowerModel, Any}","page":"Reference","title":"FLOWFarm.calculate_turbine_power","text":"calculate_turbine_power(generator_efficiency, cut_in_speed, cut_out_speed, rated_speed,\nrated_power, rotor_diameter, wt_velocity, power_model::AbstractPowerModel, air_density)\n\nCalculate the power for all wind turbines. Dispaches to desired power model.\n\nArguments\n\ngenerator_efficiency::Array{Float,nTurbines}\ncut_in_speed::Array{Float,nTurbines}\ncut_out_speed::Array{Float,nTurbines}\nrated_speed::Array{Float,nTurbines}\nrated_power::Array{Float,nTurbines}\nrotor_diameter::Array{Float,nTurbines}\nwt_velocity::Array{Float,nTurbines}: turbine effective wind speeds for current state only\n`power_model::AbstractPowerModel)\nair_density::Float\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_unstable_sparse_jacobian!-Union{Tuple{T}, Tuple{T, Vararg{Any, 5}}} where T<:FLOWFarm.UnstableSparseMethod","page":"Reference","title":"FLOWFarm.calculate_unstable_sparse_jacobian!","text":"calculateunstablesparsejacobian!(sparsestruct::T,x,farm,windstateid,prealloc_id,lock)\n\nHelper function that calculates the sparse jacobian for a single wind state using an unstable sparsity pattern\n\nArguments\n\nsparse_struct: sparseAEPstructunstablepattern struct\nx: Vector containing the design variables\nfarm: WindFarm struct\nwind_state_id: Wind state id\nprealloc_id: Preallocation id (to select the correct preallocated memory inside the wind farm struct)\nlock: SpinLock object to lock the farm struct for multithreadeding\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_unstable_sparsity_pattern!-Union{Tuple{T}, Tuple{T, Any, Any, Any}} where T<:FLOWFarm.UnstableSparseMethod","page":"Reference","title":"FLOWFarm.calculate_unstable_sparsity_pattern!","text":"calculateunstablesparsitypattern!(sparsestruct::T,x,windstateid,prealloc_id)\n\nHelper function that calculates the sparsity pattern for a single wind state using an unstable sparsity pattern\n\nArguments\n\nsparse_struct: sparseAEPstructunstablepattern struct\nx: Vector containing the design variables\nwind_state_id: Wind state id\nprealloc_id: Preallocation id (to select the correct preallocated memory inside the wind farm struct)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_wind_state_power!-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.calculate_wind_state_power!","text":"calculatewindstatepower!(pow,x,farm,stateid;preallocid=1,hoursper_year=365.25*24.0,lock=nothing)\n\nHelper function that calculates the power fora a single wind state\n\nArguments\n\npow: 1d array that holds the powers or each turbine\nx: Vector containing the  design variables\nfarm: WindFarm struct\nstate_id: Wind state id\nprealloc_id: Preallocation id (to select the correct preallocated memory inside the wind farm struct)\nhours_per_year: Single float that defines the hours per year\nlock: SpinLock object to lock the farm struct for multithreadeding\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.circle_boundary!-NTuple{5, Any}","page":"Reference","title":"FLOWFarm.circle_boundary!","text":"circle_boundary!(center,radius,turbine_x,turbine_y)\n\ncalculate the distance squared from each turbine to a circular boundary. Negative means the turbine is inside the boundary\n\nArguments\n\nboundary_vec: vector containing distances from the boundary\ncenter::Float: circular boundary center [x,y]\nradius::Float: circulat boundary radius\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.circle_boundary-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.circle_boundary","text":"circle_boundary(center,radius,turbine_x,turbine_y)\n\ncalculate the distance squared from each turbine to a circular boundary. Negative means the turbine is inside the boundary\n\nArguments\n\ncenter::Float: circular boundary center [x,y]\nradius::Float: circulat boundary radius\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.closeBndryList-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.closeBndryList","text":"closeBndryList(bndryPts_x, bndryPts_y)\n\nAppends the 1st element to the end of the coordinate arrays if it is not already repeated. Note, this will only work on 1-D arrays. For an array of 1-D arrays, use closeBndryLists(bndryPts_x, bndryPts_y) (note the plural, not singular 'Lists' in the function title)\n\nArguments\n\nbndryPts_x::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndryPts_y::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.closeBndryLists-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.closeBndryLists","text":"closeBndryLists(bndryPts_x, bndryPts_y)\n\nAppends the 1st element to the end of each array for a closed boundary. Note, this will not function properly if there is only one region. For only one region, use closeBndryList(bndryPts_x, bndryPts_y) (note the singular, not plural 'List' in the function title)\n\nArguments\n\nbndryPts_x::Array{Float,1} : N-D array of x-coordinates for the vertices       around N-many closed boundaries\nbndryPts_y::Array{Float,1} : N-D array of y-coordinates for the vertices       around N-many closed boundaries\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.coordDist-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.coordDist","text":"coordDist(x1, y1, x2, y2)\n\nGiven a two points (x1, y1) and (x2, y2), returns the euclidean distance between them\n\nArguments\n\nx1::Float64 : x-coord of the first point\ny1::Float64 : y-coord of the first point\nx2::Float64 : x-coord of the second point\ny2::Float64 : y-coord of the second point\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.define_patterns!-NTuple{6, Any}","page":"Reference","title":"FLOWFarm.define_patterns!","text":"definepatterns!(jacobians,x,farm,tolerance,pow,nstates)\n\nHelper function that defines the jacobian patterns for each wind state\n\nArguments\n\njacobians: Vector of sparse arrays holding jacobians\nx: Vector containing the  design variables\nfarm: WindFarm struct\ntolerance: Single float that defines the tolerance for the jacobian pattern\npow: 2d array that holds the powers or each turbine (used for threads)\nn_states: Number of wind states\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.define_stable_jacobian_pattern-NTuple{5, Any}","page":"Reference","title":"FLOWFarm.define_stable_jacobian_pattern","text":"definestablejacobianpattern(x,farm,tolerance,pow,stateid;prealloc_id=1)\n\nHelper function that defines the jacobian pattern for a single wind state\n\nArguments\n\nx: Vector containing the  design variables\nfarm: WindFarm struct\ntolerance: Single float that defines the tolerance for the jacobian pattern\npow: 1d array that holds the powers or each turbine\nstate_id: Wind state id\nprealloc_id: Preallocation id (to select the correct preallocated memory inside the wind farm struct)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.distributed_velocity_op","page":"Reference","title":"FLOWFarm.distributed_velocity_op","text":"distributed_velocity_op(V, Omega, r, precone, yaw, tilt, azimuth, rho, mu=1.81206e-05, asound=1.0)\n\nReturn the operating points along the blade considering varied inflow along the blade.\n\nArguments\n\nV::Array{Float}: velocity inflow at each r\nOmega::Float: rotor rotational speed\nr::Array{Float}: radial locations of interest\nprecone::Float: rotor precone angle\nyaw::Float: rotor yaw angle\ntilt::Float: rotor tilt angle\nazimuth::Float: blade azimuth angle\nrho::Float: air density\n\nKeyword Arguments\n\nmu::Float: air viscocity (can usually use the default)\nasound::Float: speed of sound (can usually use the default)\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.find_upstream_turbines-Tuple{Any, Any, AbstractArray, Any}","page":"Reference","title":"FLOWFarm.find_upstream_turbines","text":"find_upstream_turbines(turbinex, turbiney, winddirection, diameter; inverse=false)\n\nA convenience function to quickly find either which turbines are waked, or those that are not.\n\nArguments\n\nturbinex::Array{T,1}: x locations of turbines in global reference frame\nturbiney::Array{T,1}: y locations of turbines in global reference frame\nwinddirection::Real or winddirection::AbstractArray: wind direction in radians in meteorological coordinates (0 rad. = from North)\ndiameter::Array{T,1}: diameters of all wind turbines\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.find_xyz_simple-NTuple{6, Any}","page":"Reference","title":"FLOWFarm.find_xyz_simple","text":"find_xyz_simple(x_hub,y_hub,z_hub,r,yaw,azimuth)\n\nFind the xyz locations of points along a blade given it's location and azimuth angle. Currently doesn't consider precone or tilt.\n\nArguments\n\nx_hub::Float: x location of hub\ny_hub::Float: y location of hub\nz_hub::Float: z location of hub (hub height if no topology)\nr::Array{Float}: radial locations of interest\nprecone::Float: rotor precone angle\nyaw::Float: rotor yaw angle\nazimuth::Float: blade azimuth angle\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.getNextFileName","page":"Reference","title":"FLOWFarm.getNextFileName","text":"getNextFileName(directory, file_name, file_type)\n\nChecks if a file of the given directory and name exists. If not, increments to the next index so as not to overwrite previously written files. If it reaches the max number of overwrites, it will default to <directory/filename.filetype> To default to this, set <max_check=0> in function call.\n\nArguments\n\ndirectory::String: path/to/write/file/at/\nfile_name::String: Whatever the name of the file desired\nfile_type::String: ex \"yaml\", \"txt\", \"csv\", etc...\nmax_check::Int: the maximum number of files to check\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.getPerimeterLength-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.getPerimeterLength","text":"getPerimeterLength(bndry_x_clsd, bndry_y_clsd)\n\nGiven a 1-D closed array of boundary verticies (with first point repeated at the end) returns the length along the perimeter. Created to be used in VRbounarystartup()\n\nArguments\n\nbndry_x::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndry_y::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.getUpDwnYvals-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.getUpDwnYvals","text":"getUpDwnYvals(turbine_x, bndry_x_clsd, bndry_y_clsd, bndry_corner_indcies)\n\nSupplements FLOWFarm's splinedboundary() function by calculating (for a given x location) the maximum and minimum y-value permitted to remain \"inside\" the boundary. If turbinex is located left of the boundary's leftmost vertex or right of the boundary's rightmost vertex, it return's that corresponding vertex's y-value as the max and min, as default. Returns two values, the minimum and maximum interior y-values withing a boundary for the given turbine_x value. Note that all boundary coordinates must be in the first quadrant of the Cartesian coordinate system (+x and +y values only)\n\nArguments\n\nturbine_x::Array{Float}: x-value of the turbine being examined\nbndry_x_clsd::Array{Float}: x locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.\nbndry_y_clsd::Array{Float}: y locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.\nbndry_corner_indcies::Array{Float}: An array of 3 or 4 indicies in the       bndryx/yclsd arrays that correspond to the three four \"corners\" used       between splined \"sides\"\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_boundary_yaml-Tuple{Any}","page":"Reference","title":"FLOWFarm.get_boundary_yaml","text":"get_boundary_yaml(filename)\n\nReturns the boundaries of a wind farm as defined in a yaml file in the format used in FLOWFarm. Returns N by 2 array for single region farm and an array of N by 2 arrays for multiple regions. Returned regions are sorted alphabetically by the keys provided in the yaml file.\n\nArguments\n\nfile_name::String: relative/path/to/file\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_moments-NTuple{7, Any}","page":"Reference","title":"FLOWFarm.get_moments","text":"get_moments(out,Rhub,Rtip,r,az,precone,tilt)\n\nTrapezoidal integration to find the blade root bending moment using the loads distribution\n\nArguments\n\n`out::CCBlade dict: output from running CCBlade solve\nRhub::Float: radius of the rotor hub\nRtip::Float: radius of the blade tip\nr::Array{Float}: radial locations of interest\naz::Float: blade azimuth angle\nprecone::Float: rotor precone angle\ntilt::Float: rotor tilt angle\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_peaks-Tuple{Any}","page":"Reference","title":"FLOWFarm.get_peaks","text":"get_peaks(array)\n\nget the turning point values of a signal\n\nArguments\n\narray::Array{Float}: the signal to find the turning points, or peaks\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_peaks_indices-Tuple{Any}","page":"Reference","title":"FLOWFarm.get_peaks_indices","text":"get_peaks_indices(array)\n\nreturn the indices of the signal peaks\n\nArguments\n\narray::Array{Float}: the signal to find the turning points, or peaks\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_turb_atrbt_YAML-Tuple{Any}","page":"Reference","title":"FLOWFarm.get_turb_atrbt_YAML","text":"get_turb_atrbt_YAML(file_name)\n\nread in turbine attributes from .yaml\n\nArguments\n\nfile_name::String: path/to/attribute/file.yaml\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_turb_loc_YAML-Tuple{Any}","page":"Reference","title":"FLOWFarm.get_turb_loc_YAML","text":"get_turb_loc_YAML(file_name)\n\nread in turbine locations and related problem file names from .yaml\n\nArguments\n\nfile_name::String: path/and/name/of/location/file.yaml\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_wind_rose_YAML-Tuple{Any}","page":"Reference","title":"FLOWFarm.get_wind_rose_YAML","text":"get_wind_rose_YAML(file_name)\n\nread in wind resource information from .yaml\n\nArguments\n\nfile_name::String: path/to/wind/resource/file.yaml\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.grid_points-Tuple{Any}","page":"Reference","title":"FLOWFarm.grid_points","text":"grid_points(n)\n\nGenerates points in a grid. If n is not a perfect square, then the nearest square root will be used for the side length of the grid.\n\nArguments\n\nn::Float: number of points to generate\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.hermite_spline-NTuple{7, Any}","page":"Reference","title":"FLOWFarm.hermite_spline","text":"hermite_spline(x, x0, x1, y0, dy0, y1, dy1)\n\nProduces the y and (optionally) dy values for a hermite cubic spline interpolating between two end points with known slopes\n\nArguments\n\nx::Float: x position of output y\nx0::Float: x position of upwind endpoint of spline\nx1::Float: x position of downwind endpoint of spline\ny0::Float: y position of upwind endpoint of spline\ndy0::Float: slope at upwind endpoint of spline\ny1::Float: y position of downwind endpoint of spline\ndy1::Float: slope at downwind endpoint of spline\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.iea37cs4BndryVRIntPM-NTuple{6, Any}","page":"Reference","title":"FLOWFarm.iea37cs4BndryVRIntPM","text":"iea37cs4BndryVRIntPM(bndry_x_clsd, bndry_y_clsd, bndry_corner_indcies, turbine_x, turbine_y, turb_diam, turb_min_space, num_turbs_to_place)\n\nUses the Variable reduction method for placing boundary turbines, and the Partition Method (from splined_boundary()) for random interior points, maintaining proper spacing from all previously placed turbines.\n\nArguments\n\nbndry_x_clsd::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndry_y_clsd::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\nbndry_corner_indcies::Float64: The indicies within <bndryxclsd> and       <bndryyclsd> which denote the \"corners\" adjacent turbines\n'turbminspace::Float64`: For proximity knowledge, the minimum spacing       required between any two turbines\n'numbndryturbs::Float64`: The number of turbines desired to be placed along       the boundary. If too many are selected (due to spacing condtraints), the       remaining will be placed in the interior\n'numtotturbs::Float64`: The number of total turbines to be placed both on       the boundary and in the interior\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.latlong_to_xy-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm.latlong_to_xy","text":"latlong_to_xy(latitude, longitude, utm_zone; isnorth=true, units=\"m\")\n\nConverts arrays of points from latitude and longitude to x and y in meters in a local coordinate frame based on the point with the lowest magnitude latitude,\n\nArguments\n\nlatitude::Array{Float,N}\nlongitude::Array{Float,N}\nisnorth::Float: specifies if the point is in the northern hemisphere (defaul: true)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.met2cart-Tuple{Number}","page":"Reference","title":"FLOWFarm.met2cart","text":"met2cart(angle_met)\n\nConvert from meteorological polar system (CW, 0 rad.=N, wind from) to cartesian polar system (CCW, 0 rad.=E, wind to).\n\nArguments\n\nangle_met::Number: an angle in radians in a meteorological coordinate system\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.multiple_components_op","page":"Reference","title":"FLOWFarm.multiple_components_op","text":"multiple_components_op(U, V, W, Omega, r, precone, yaw, tilt, azimuth, rho, mu=1.81206e-05, asound=1.0)\n\nReturn the operating points along the blade considering all the inflow velocity components.\n\nArguments\n\nU::Array{Float}: u velocity component of the inflow at each r\nV::Array{Float}: v velocity component of the inflow at each r\nW::Array{Float}: w velocity component of the inflow at each r\nOmega::Float: rotor rotational speed\nr::Array{Float}: radial locations of interest\nprecone::Float: rotor precone angle\nyaw::Float: rotor yaw angle\ntilt::Float: rotor tilt angle\nazimuth::Float: blade azimuth angle\nrho::Float: air density\n\nKeyword Arguments\n\nmu::Float: air viscocity (can usually use the default)\nasound::Float: speed of sound (can usually use the default)\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.nansafenorm-Tuple{Vector}","page":"Reference","title":"FLOWFarm.nansafenorm","text":"nansafenorm(v)\n\nCalculate the norm of a vector, but if the sum of the squares is less than the given tolerance then use the line y = a(sqrt(eps())/eps()) so that the derivative is well defined.\n\nArguments\n\nv::Vector{}: takes the norm of this vector, but avoids NaN by using a linear   approximation of sqrt near 0.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.nansafesqrt-Tuple{Number}","page":"Reference","title":"FLOWFarm.nansafesqrt","text":"nansafesqrt(a)\n\nCalculate the square root of a number, but if the number is less than the given tolerance then use the line y = a(sqrt(eps())/eps()) so that the derivative is well defined.\n\nArguments\n\na::Number: takes the square root of this value, or approximates it with a line for a < eps()\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.point_velocity-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet, Vararg{Any, 4}}","page":"Reference","title":"FLOWFarm.point_velocity","text":"point_velocity(loc, turbine_x, turbine_y, turbine_z, turbine_yaw, turbine_ct, turbine_ai,\nrotor_diameter, hub_height, turbine_local_ti, sorted_turbine_index, wtvelocities,\nwind_resource, model_set::AbstractModelSet;\nwind_farm_state_id=1, downwind_turbine_id=0)\n\nCalculates the wind speed at a given point for a given state\n\nArguments\n\nloc::Array{TF,3}: Location of interest\nturbine_x::Array{TF,nTurbines}: turbine east-west locations in the state   reference frame\nturbine_y::Array{TF,nTurbines}: turbine north-south locations in the state   reference frame\nturbine_z::Array{TF,nTurbines}: turbine base height in the state reference frame\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in   radians\nturbine_ct::Array{TF,nTurbines}: turbine thrust coefficients for the given state\nturbine_ai::Array{TF,nTurbines}: turbine axial induction for the given state\nrotor_diameter::Array{TF,nTurbines}: turbine rotor diameters\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_local_ti::Array{TF,nTurbines}: turbine local turbulence intensity for   the given state\nsorted_turbine_index::Array{TF,nTurbines}: array containing indices of wind turbines   from most upwind to most downwind turbine in the given state\nwtvelocities::Array{TF,nTurbines}: effective inflow wind speed for given state\nwind_resource::DiscretizedWindResource: contains wind resource discreption (directions,   speeds, frequencies, etc)\nwind_farm_state_id::Int: index to correct state to use from wind resource provided.   Defaults to 1\ndownwind_turbine_id::Int: index of wind turbine of interest (if any). If not a point for   calculating effective wind speed of a turbine, then provide 0 (default)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.pointinpolygon","page":"Reference","title":"FLOWFarm.pointinpolygon","text":"pointinpolygon(point, vertices, normals=nothing; s=700, method=\"raycasting\", shift=1E-10, return_distance=true)\n\nGiven a polygon determined by a set of vertices, determine the signed distance from the point to the polygon.\n\nReturns the negative (-) distance if the point is inside or on the polygon, positive (+) otherwise. If return_distance is set to false, then returns -1 if in polygon or on the boundary, and 1 otherwise.\n\nArguments\n\npoint::Vector{Number}(2): point of interest\nvertices::Vector{Matrix{Number}(2): vertices of polygon\nnormals::Vector{Matrix{Number}(2): if not provided, they will be calculated\ns::Number: smoothing factor for ksmax function (smoothmax)\nmethod::String: currently only raycasting is available\nshift::Float: how far to shift point if it lies on an edge or vertex\nreturn_distance::Bool: if true, return distance. if false, return -1 if in polygon or on the boundary, and 1 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.pointonline-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm.pointonline","text":"pointonline(p, v1, v2; tol=1E-6)\n\nGiven a line determined two points (v1 and v2) determine if the point (p) lies on the line between those points.\n\nReturns true if the point lies on the line (within the given tolerance), false otherwise.\n\nArguments\n\np::Vector{Number}(2): point of interest\nv1::Vector{Number}(2): first vertex of the line\nv2::Vector{Number}(2): second vertex of the line\ntol::Number: how close the cumulative distance from v1 to p to v2 must be to the distance from v1 to v2 to count as being co-linear\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.rainflow","page":"Reference","title":"FLOWFarm.rainflow","text":"rainflow(array_ext,uc_mult=0.5)\n\nRainflow counting of a signal's turning points\n\nArguments\n\n    array_ext (numpy.ndarray): array of turning points\n\nKeyword Arguments\n\n    uc_mult (float): partial-load scaling [opt, default=0.5]\n\nReturns\n\n    array_out (numpy.ndarray): (3 x n_cycle) array of rainflow values:\n                                1) load range\n                                2) range mean\n                                3) cycle count\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.ray_casting_boundary-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.ray_casting_boundary","text":"ray_casting_boundary(boundary_vertices,boundary_normals,turbine_x,turbine_y)\n\nCalculate the distance from each turbine to the nearest point on the boundary using the ray-casting algorithm. Negative means the turbine is inside the boundary.\n\nArguments\n\nboundary_vertices::Array{Float,2}: vertices of the boundary CCW in order s.t.       boundaryVertices[i] -> first point of face for unit_normals[i]\nboundary_normals::Array{Float,2}: unit normal vector for each boundary face       CCW where boundaryVertices[i] is the first point of the corresponding face\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\ndiscrete::Bool: if true, indicates the boundary is made of multiple discrete regions\ns::Number: smoothing factor for smooth max (ksmax)\ntol::Float: how close points have to be to vertex or face before they will be shifted slightly to avoid a discontinuity\nreturn_region::bool: if true, return a vector specifying which region each turbine is in\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.recolor_jacobian!-Union{Tuple{T}, Tuple{T, Any, Any, Any}} where T<:FLOWFarm.UnstableSparseMethod","page":"Reference","title":"FLOWFarm.recolor_jacobian!","text":"recolorjacobian!(sparsestruct::T,windstateid,nvariables,nturbines)\n\nHelper function that recolors the jacobian for a single wind state\n\nArguments\n\nsparse_struct: sparseAEPstructunstablepattern struct\nwind_state_id: Wind state id\nn_variables: Number of design variables\nn_turbines: Number of turbines\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.rediscretize_windrose-Tuple{DiscretizedWindResource, Any}","page":"Reference","title":"FLOWFarm.rediscretize_windrose","text":"rediscretize_windrose(windrosein::DiscretizedWindResource, ndirectionbins, nspeedbins)\n\nFunction for re-interpreting a wind rose into a desired number of bins. Returns the new\nwind rose. Currently only works for windroses with a single speed in each direction.\n\nArguments\n\nwindrosein::DiscretizedWindResource: original wind rose\nndirectionbins::Integer: number of direction bins for the new wind rose\nstart::Float: direction for first bin in radians\naveragespeed::Bool: set whether or not to return the average wind speed as the speed for all bins\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.rotate_to_wind_direction-Tuple{Any, Any, Number}","page":"Reference","title":"FLOWFarm.rotate_to_wind_direction","text":"rotate_to_wind_direction(xlocs, ylocs, wind_direction_met)\n\nRotates wind farm coordinates to be in wind direction reference where wind direction is to the positive x.\n\nArguments\n\nxlocs::Array: contains turbine east-west locations in the global reference frame\nylocs::Array: contains turbine north-south locations in the global reference frame\nwind_direction_met::Array: contains wind direction in radians in meteorological standard   system (N=0 rad, proceeds CW, wind from direction given)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.rotor_sample_points","page":"Reference","title":"FLOWFarm.rotor_sample_points","text":"rotor_sample_points(nsamplepoints=1)\n\nInitializes the sampling locations in the rotor-swept-area. Returns values such that zero is at the turbine hub location and 1 is at the tip of the blades. If a single sample is requested, it will be at the hub location. Otherwise, the points will be located using the sunflower packcing algorithm.\n\nArguments\n\nnsamplepoints::Int: controls how many sample points to generate\nalpha::Float: Controls smoothness of the sunflower algorithm boundary. alpha=0 is the standard \"jagged edge\" sunflower algoirthm and   alpha=1 results in a smooth boundary.\npradius::Float: the percent of the rotor radius to use in generating initial point grid\nuse_perimeter_points: whether or not to include point exactly on the perimeter of the   rotor swept area\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.round_farm_random_start-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm.round_farm_random_start","text":"round_farm_random_start(rotor_diameter, center, radius; min_spacing=2., min_spacing_random=3., method=\"individual\")\n\nGenerates starting locations for multi-start optimization approaches when the farm boundary is round.\n\nArguments\n\nrotor_diameter::Number: wind turbine diameter\ncenter::Number: wind farm center\nradius::Number: wind farm radius\ndiameter::Array{T,1}: diameters of all wind turbines\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.smooth_max-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.smooth_max","text":"smooth_max_ndim(x; s=100.0)\n\nCalculate the smooth-max (a.k.a. softmax or LogSumExponential) of the elements in x.\n\nBased on John D. Cook's writings at (1) https://www.johndcook.com/blog/2010/01/13/soft-maximum/ and (2) https://www.johndcook.com/blog/2010/01/20/how-to-compute-the-soft-maximum/\n\nArguments\n\nx::Float: first value for comparison\ny::Float: second value for comparison\ns::Float : controls the level of smoothing used in the smooth max\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.smooth_max-Tuple{Any}","page":"Reference","title":"FLOWFarm.smooth_max","text":"smooth_max(x; s=10.0)\n\nCalculate the smoothmax (a.k.a. softmax or LogSumExponential) of the elements in x.\n\nBased on John D. Cook's writings at (1) https://www.johndcook.com/blog/2010/01/13/soft-maximum/ and (2) https://www.johndcook.com/blog/2010/01/20/how-to-compute-the-soft-maximum/\n\nAnd based on article in FeedlyBlog (3) https://blog.feedly.com/tricks-of-the-trade-logsumexp/\n\nArguments\n\nx::Array{Float,1} : vector with all the input values\ns::Float : controls the level of smoothing used in the smooth max\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.sparse_spacing!-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.sparse_spacing!","text":"sparsespacing!(spacingvec,turbinex,turbiney,relevant)\n\nHelper function that calculates the relevant spacing constraints\n\nArguments\n\nspacing_vec: Vector containing the spacing constraints\nturbine_x: Vector containing x positions of turbines\nturbine_y: Vector containing y positions of turbines\nrelevant: 2d array that holds the relevant turbine pairs for the spacing constraint\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.splined_boundary!-NTuple{6, Any}","page":"Reference","title":"FLOWFarm.splined_boundary!","text":"splined_boundary!(bndry_cons, turbine_x, turbine_y, bndry_x_clsd, bndry_y_clsd, bndry_corner_indcies)\n\ncalculate the distance from each turbine to a closed boundary made up of zero or more reflex angles (concavities). Boundary will have three or four user-selected \"corners\", such that the \"sides\" between corners (that will be splined) are injective functions (meaning that for every x-coord, there exists only one corresponding y-coord). Returns four values for every turbine, corresponding to the distance from the turb to the upper, lower, left, and right splined \"sides\". A negative return value means the turb is inside the boundary for that \"side\". Returns a single array of {Float64} of length {length(turbine_x) * 4}. Note that all boundary coordinates must be in the first quadrant of the Cartesian coordinate system (+x and +y values only)\n\nArguments\n\nbndry_cons:: Vector{Float}: boundary constraints\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\nbndry_x_clsd::Array{Float}: x locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.\nbndry_y_clsd::Array{Float}: y locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.\nbndry_corner_indcies::Array{Float}: An array of 3 or 4 indicies in the       bndryx/yclsd arrays that correspond to the three four \"corners\" used       between splined \"sides\"\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.splined_boundary-NTuple{5, Any}","page":"Reference","title":"FLOWFarm.splined_boundary","text":"splined_boundary(turbine_x, turbine_y, bndry_x_clsd, bndry_y_clsd, bndry_corner_indcies)\n\ncalculate the distance from each turbine to a closed boundary made up of zero or more reflex angles (concavities). Boundary will have three or four user-selected \"corners\", such that the \"sides\" between corners (that will be splined) are injective functions (meaning that for every x-coord, there exists only one corresponding y-coord). Returns four values for every turbine, corresponding to the distance from the turb to the upper, lower, left, and right splined \"sides\". A negative return value means the turb is inside the boundary for that \"side\". Returns a single array of {Float64} of length {length(turbine_x) * 4}. Note that all boundary coordinates must be in the first quadrant of the Cartesian coordinate system (+x and +y values only)\n\nArguments\n\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\nbndry_x_clsd::Array{Float}: x locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.\nbndry_y_clsd::Array{Float}: y locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.\nbndry_corner_indcies::Array{Float}: An array of 3 or 4 indicies in the       bndryx/yclsd arrays that correspond to the three four \"corners\" used       between splined \"sides\"\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.sunflower_points-Tuple{Any}","page":"Reference","title":"FLOWFarm.sunflower_points","text":"sunflower_points(n; alpha=0.0)\n\nGenerates points in a circle of radius=1 using the sunflower packing algorithm.\n\nArguments\n\nn::Float: number of points to generate\nalpha::Float: Controls the smoothness of the boundary. alpha=0 is the standard \"jagged edge\" sunflower algoirthm and   alpha=1 results in a smooth boundary.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.turbine_powers_one_direction-NTuple{10, Any}","page":"Reference","title":"FLOWFarm.turbine_powers_one_direction","text":"turbine_powers_one_direction((generator_efficiency, cut_in_speed, cut_out_speed,\n    rated_speed, rated_power, rotor_diameter, turbine_inflow_velcities, air_density, power_model::AbstractPowerModel)\n\nCalculate the power for all wind turbines for a given state\n\nArguments\n\ngenerator_efficiency::Array{Float,nTurbines}\ncut_in_speed::Array{Float,nTurbines}\ncut_out_speed::Array{Float,nTurbines}\nrated_speed::Array{Float,nTurbines}\nrated_power::Array{Float,nTurbines}\nrotor_diameter::Array{Float,nTurbines}\nturbine_inflow_velcities::Array{Float,nTurbines}: for current state only\nair_density::Float\npower_models::Array{nturbines}) elements of array should be be of sub-types or AbstractPowerModel\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.turbine_spacing!-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm.turbine_spacing!","text":"turbine_spacing!(spacing_vec,turbine_x,turbine_y)\n\nCalculate the distance between turbines in a wind farm. There is an infinite gradient of this function if two points are exactly the same. This can be avoided by returning the square of the turbine spacing rather than the actual distance, but it makes the gradients scale much more poorly. Because it is very vanishingly rare to have turbines exactly in the same location, this function leaves the square root in the calculations.\n\nArguments\n\nspacing_vec::Array{Float}: vector of distances between turbines\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.turbine_spacing-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.turbine_spacing","text":"turbine_spacing(turbine_x,turbine_y)\n\nCalculate the distance between turbines in a wind farm. There is an infinite gradient of this function if two points are exactly the same. This can be avoided by returning the square of the turbine spacing rather than the actual distance, but it makes the gradients scale much more poorly. Because it is very vanishingly rare to have turbines exactly in the same location, this function leaves the square root in the calculations.\n\nArguments\n\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.turbine_velocities_one_direction-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}","page":"Reference","title":"FLOWFarm.turbine_velocities_one_direction","text":"turbine_velocities_one_direction(turbine_x, turbine_y, turbine_z, rotor_diameter, hub_height, turbine_yaw,\nsorted_turbine_index, ct_model, rotor_sample_points_y, rotor_sample_points_z, wind_resource,\nmodel_set::AbstractModelSet; wind_farm_state_id::Int=1, velocity_only::Bool=true, turbine_velocities=nothing,\nturbine_ct=nothing, turbine_ai=nothing, turbine_local_ti=nothing)\n\nArguments\n\nturbine_x::Array{TF,nTurbines}: turbine east-west locations in the state   reference frame\nturbine_y::Array{TF,nTurbines}: turbine north-south locations in the state   reference frame\nturbine_z::Array{TF,nTurbines}: turbine base height in the state reference frame\nrotor_diameter::Array{TF,nTurbines}: turbine rotor diameters\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in   radians\nsorted_turbine_index::Array{TF,nTurbines}: turbine sorted order upstream to downstream   for given state\nct_model::AbstractThrustCoefficientModel: defines how the thrust coefficient changes   with state etc\nrotorsamplepoints_y::Array{TF,N}`: horizontal wind location of points to sample across   the rotor swept area when calculating the effective wind speed for the wind turbine.   Points are centered at the hub (0,0) and scaled by the radius (1=tip of blades)\nrotorsamplepoints_z::Array{TF,N}`: vertical wind location of points to sample across the   rotor swept area when calculating the effective wind speed for the wind turbine. Points   are centered at the hub (0,0) and scaled by the radius (1=tip of blades)\nwind_resource::DiscretizedWindResource: wind resource discreption (directions, speeds,   frequencies, etc)\nmodel_set::AbstractModelSet: defines wake-realated models to be used in analysis\nwind_farm_state_id::Int: index to correct state to use from wind resource provided.   Defaults to 1\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.unstable_sparse_aep_gradient!-Union{Tuple{T}, Tuple{T, Any, Any, Any}} where T<:FLOWFarm.UnstableSparseMethod","page":"Reference","title":"FLOWFarm.unstable_sparse_aep_gradient!","text":"unstablesparseaepgradient!(sparsestruct::T,x,farm,windstateid;prealloc_id=1,lock=nothing)\n\nFunction that calculates the AEP gradient for a single wind state using an unstable sparsity pattern\n\nArguments\n\nsparse_struct: sparseAEPstructunstablepattern struct\nx: Vector containing the design variables\nfarm: WindFarm struct\nwind_state_id: Wind state id\nprealloc_id: Preallocation id (to select the correct preallocated memory inside the wind farm struct)\nlock: SpinLock object to lock the farm struct for multithreadeding\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.update_safe_design_variables!-Union{Tuple{T}, Tuple{T, Any}} where T<:FLOWFarm.AbstractSparseMethod","page":"Reference","title":"FLOWFarm.update_safe_design_variables!","text":"updatesafedesignvariables!(spacingstruct::T,x)\n\nFunction that updates the safe design variables for the spacing constraints\n\nArguments\n\nspacing_struct: sparsespacingstruct struct\nx: Vector containing the design variables\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.update_turbine_powers!-Union{Tuple{T}, Tuple{T, Any}} where T<:FLOWFarm.StableSparseMethod","page":"Reference","title":"FLOWFarm.update_turbine_powers!","text":"updateturbinepowers!(sparse_struct::T,i)\n\nHelper function that updates the turbine powers for a single wind state from the sparse struct\n\nArguments\n\nsparse_struct: sparseAEPstructstablepattern struct\ni: Wind state id\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_count_iec-Tuple{Any, Any, Real, Any}","page":"Reference","title":"FLOWFarm.wake_count_iec","text":"wake_count_iec(turbinex, turbiney, winddirection, diameter; return_turbines=true)\n\nAdapted from NREL's floris\n\nFinds the number of turbines waking each turbine for the given\nwind direction. Waked directions are determined using the formula\nin Figure A.1 in Annex A of the IEC 61400-12-1:2017 standard.\n\nArguments\n\nturbinex::Array{T,1}: x locations of turbines in global reference frame\nturbiney::Array{T,1}: y locations of turbines in global reference frame\nwinddirection::Float: wind direction in radians in meteorological coordinates (0 rad. = from North)\ndiameter::Array{T,1}: diameters of all wind turbines\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, CumulativeCurl}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, wake_deficits, contribution_matrix, deflections, current_index_loop, wind_speed_internal, sigma_squared, wtvelocities, sorted_turbine_index, model::CumulativeCurl)\n\nComputes the wake deficit at a given location using the Cumulative Curl Model https://doi.org/10.5194/wes-2022-17\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated\nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake\ndeflection_z::Float: deflection in the z direction of downstream wake\nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nwake_deficits: matrix containing the wake deficits from every turbine to every other turbine for use in sparsity codes\ncontribution_matrix: matrix containing the contribution coefficients defined in the Cumlative Curl Model\nmodel::CumulativeCurl: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, GaussOriginal}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::GaussOriginal)\n\nComputes the wake deficit at a given location using the Gaussian wake model presented by Bastankhah and Porte-Agel in the paper: \"A new analytical model for wind-turbine wakes\" (2014)\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated\nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake\ndeflection_z::Float: deflection in the z direction of downstream wake\nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::GaussOriginal: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, GaussSimple}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, wake_deficits, contribution_matrix, deflections, current_index_loop, wind_speed_internal, sigma_squared, wtvelocities, sorted_turbine_index, model::GaussSimple)\n\nComputes the wake deficit at a given location using the Gaussian wake model presented by Bastankhah and Porte-Agel in the paper: \"A new analytical model for wind-turbine wakes\" (2014)     as modified for IEA Task 37 Case Studies 3 and 4\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated\nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake\ndeflection_z::Float: deflection in the z direction of downstream wake\nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::GaussSimple: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, GaussYawVariableSpread}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, wake_deficits, contribution_matrix, deflections, current_index_loop, wind_speed_internal, sigma_squared, wtvelocities, sorted_turbine_index, model::GaussYawVariableSpread)\n\nComputes the wake deficit at a given location using the The Gaussian wake model presented by Bastankhah and Porte-Agel in the paper: \"Experimental and theoretical study of wind turbine wakes in yawed conditions\" (2016) The spread rate is adjusted based on local turbulence intensity as in Niayifar and Porte-Agel 2016\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated\nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake\ndeflection_z::Float: deflection in the z direction of downstream wake\nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::GaussYawVariableSpread: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, GaussYaw}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::GaussYaw)\n\nComputes the wake deficit at a given location using the The Gaussian wake model presented by Bastankhah and Porte-Agel in the paper: \"Experimental and theoretical study of wind turbine wakes in yawed conditions\" (2016)\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated\nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake\ndeflection_z::Float: deflection in the z direction of downstream wake\nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::GaussYaw: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, JensenCosine}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::JensenCosine)\n\nComputes the wake deficit according to the original Jensen cosine wake model, from the paper: \"A Note on Wind Generator Interaction\" by N.O. Jensen (1983)\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated\nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake\ndeflection_z::Float: deflection in the z direction of downstream wake\nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::JensenCosine: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, JensenTopHat}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::JensenTopHat)\n\nComputes the wake deficit according to the original Jensen top hat wake model, from the paper: \"A Note on Wind Generator Interaction\" by N.O. Jensen (1983)\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated\nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake\ndeflection_z::Float: deflection in the z direction of downstream wake\nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::JensenTopHat: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, MultiZone}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::MultiZone)\n\nComputes the wake deficit at a given location using the original MultiZone \"FLORIS\" wake model, from the paper: \"Wind plant power optimization through yaw control using a parametric model for wake effects—a CFD simulation study\" by Gebraad et al. (2014)\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated\nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake\ndeflection_z::Float: deflection in the z direction of downstream wake\nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::MultiZone: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, GaussYawDeflection}","page":"Reference","title":"FLOWFarm.wake_deflection_model","text":"wake_deflection_model(locx, locy, locz, turbine_x, turbine_yaw, turbine_ct, turbine_id, rotor_diameter, turbine_local_ti, model::GaussYawDeflection)\n\nCalculates the horizontal deflection of the wind turbine wake\n\nBased on:\n[1] Bastankhah and Porte-Agel 2016 \"Experimental and theoretical study of\nwind turbine wakes in yawed conditions\"\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, GaussYawVariableSpreadDeflection}","page":"Reference","title":"FLOWFarm.wake_deflection_model","text":"wake_deflection_model(oc, turbine_x, turbine_yaw, turbine_ct, turbine_id, rotor_diameter, turbine_local_ti, model::GaussYawVariableSpreadDeflection)\n\nCalculates the horizontal deflection of the wind turbine wake. Varies based on local turbulence intensity.\n\nBased on:\n[1] Bastankhah and Porte-Agel 2016 \"Experimental and theoretical study of\nwind turbine wakes in yawed conditions\"\n[2] Niayifar and Porte-Agel 2016 \"Analytical Modeling of Wind Farms:\nA New Approach for Power Prediction\"\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, JiminezYawDeflection}","page":"Reference","title":"FLOWFarm.wake_deflection_model","text":"wake_deflection_model(locx, locy, locz, turbine_id, turbine_definition::TurbineDefinition, model::JiminezYawDeflection)\n\nCalculates the horizontal deflection of the wind turbine wake\n\nBased on:\n[1] Jiminez 2010 \"Wake defl ection of a wind turbine in yaw\"\n[2] Gebraad 2014 \"Wind plant optimization by yaw control using a parametric wake model\"\nthis version ignores the corrections made to the yaw model for rotor rotation as described in [2] and\n[3] Thomas 2017 \"Improving the FLORIS wind plant model for compatibility with gradient-based optimization\"\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, NoYawDeflection}","page":"Reference","title":"FLOWFarm.wake_deflection_model","text":"wake_deflection_model(locx, locy, locz, turbine_id, turbine_definition::TurbineDefinition, model::NoYawDeflection, windfarmstate::SingleWindFarmState)\n\nBypasses yaw deflection calculations.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.write_turb_loc_YAML-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm.write_turb_loc_YAML","text":"write_turb_loc_YAML(file_name, data)\n\nwrite turbine locations and related information to .yaml\n\nArguments\n\nfile_name::String: path/and/name/of/location/file.yaml\n\n\n\n\n\n","category":"method"},{"location":"Tutorial/#Tutorial","page":"Quick Start","title":"Tutorial","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"This tutorial covers the basics of FlowFARM. For more specifics refer to the How-to guide.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"This tutorial discusses how to do the following with FLOWFarm:","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"(1) setting up a problem description\n(2) setting up an analysis model set\n(3) running analyses\n(4) setting up and running an optimization\n(5) calculating and visualizing a flow field","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Details for setting up an optimization will depend heavily on the optimization package you are using, your objective, and your design variables. Optimization examples using various packages are provided in the example scripts located in the test  directory.","category":"page"},{"location":"Tutorial/#(1)-Setting-up-the-problem-description","page":"Quick Start","title":"(1) Setting up the problem description","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The problems description involves the physical description of the wind farm, the turbines,  and the wind resource. While this tutorial uses the same design across all the wind turbines and mostly equal properties across all wind flow states, all turbines and flow states can  be unique.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"For API demonstration purposes, we have directly assigned all values. However, values may  be loaded from .csv and/or .yaml files.","category":"page"},{"location":"Tutorial/#Set-up-the-running-environment","page":"Quick Start","title":"Set up the running environment","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"using FLOWFarm; const ff = FLOWFarm\nusing SNOW","category":"page"},{"location":"Tutorial/#Initialize-the-wind-farm-design","page":"Quick Start","title":"Initialize the wind farm design","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"\n# set initial turbine x and y locations\nturbinex = [-240.0, -240.0, -240.0, 0.0, 0.0, 0.0, 240.0, 240.0, 240.0]\nturbiney = [-240.0, 0.0, 240.0, -240.0, 0.0, 240.0, -240.0, 0.0, 240.0]\n\n# get the number of turbines\nnturbines = length(turbinex)\n\n# set turbine base heights\nturbinez = zeros(nturbines)\n\n# set turbine yaw values\nturbineyaw = zeros(nturbines)\n\n# set wind farm boundary parameters in meters (we won't really need this until we optimize)\nboundarycenter = [0.0,0.0]\nboundaryradius = hypot(300, 300) \nprintln(\"\") # hide","category":"page"},{"location":"Tutorial/#Initialize-wind-turbine-design","page":"Quick Start","title":"Initialize wind turbine design","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# set turbine design parameters (these values correspond to the Vestas V80 turbine)\nrotordiameter = zeros(nturbines) .+ 80.0   # m\nhubheight = zeros(nturbines) .+ 70.0           # m\ncutinspeed = zeros(nturbines) .+ 4.0           # m/s\ncutoutspeed = zeros(nturbines) .+ 25.0         # m/s\nratedspeed = zeros(nturbines) .+ 16.0          # m/s\nratedpower = zeros(nturbines) .+ 2.0E6         # W\ngeneratorefficiency = ones(nturbines)\nprintln(\"\") # hide","category":"page"},{"location":"Tutorial/#Determine-how-to-sample-the-flow-field-to-determine-effective-inflow-speeds","page":"Quick Start","title":"Determine how to sample the flow field to determine effective inflow speeds","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Rotor swept area sample points are normalized by the rotor radius. These arrays define which which points on the rotor swept area should be used to estimate the effective inflow wind speed for each wind turbine. Values of 0.0 are at the rotor hub, 1.0 is at the blade tip, z is vertical, and y is horizontal. These points track the rotor when yawed.  A single sample point will always be placed at the hub. More points can be arranged in  either a grid pattern or a sunflower packing pattern with various options.  See doc strings for more information.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# get the sample points\nnsamplepoints = 50\nrotorsamplepointsy, rotorsamplepointsz = ff.rotor_sample_points(nsamplepoints, method=\"sunflower\")","category":"page"},{"location":"Tutorial/#Setting-up-the-wind-resource","page":"Quick Start","title":"Setting up the wind resource","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The wind resource determines the properties of the flowfield at all wind states. A wind  state is any combination of wind speed, wind direction, turbulence intensity, etc...","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# set flow parameters\nwindspeed = 8.0        # m/2\nairdensity = 1.1716    # kg/m^3\nambientti = 0.1      # %\nshearexponent = 0.15\nndirections = 5\nwinddirections = collect(range(0, 2*pi*(1-1/ndirections), length=ndirections))   # radians\nwindspeeds = ones(ndirections).*windspeed   # m/s\nwindprobabilities = ones(ndirections).*(1.0/ndirections)       # %\nambienttis = ones(ndirections).*ambientti  # %\nmeasurementheight = ones(ndirections).*hubheight[1] # m\n\n# initialize the wind shear model\nwindshearmodel = ff.PowerLawWindShear(shearexponent)\n\n# initialize the wind resource definition\nwindresource = ff.DiscretizedWindResource(winddirections, windspeeds, windprobabilities, \nmeasurementheight, airdensity, ambienttis, windshearmodel)","category":"page"},{"location":"Tutorial/#(2)-Setting-up-the-analysis-models","page":"Quick Start","title":"(2) Setting up the analysis models","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"A model set requires a Wake Deficit Model, Wake Deflection Model, Wake Combination Model, and a Local Turbulence Intensity Model. There are several options for each model type. To facilitate research studies, any of the models in each type can be used with any of the models in any other type. However, behavior is not guaranteed. It is recommended that common, validated, model combinations be used in most cases.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Model types and options are:","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Deficit Models: JensenTopHat, JensenCosine, MultiZone, GaussOriginal, GaussYaw, GaussYawVariableSpread, GaussSimple\nDeflection Models: GaussYawDeflection, GaussYawVariableSpreadDeflection, JiminezYawDeflection, MultizoneDeflection\nCombination Models: LinearFreestreamSuperposition, SumOfSquaresFreestreamSuperposition SumOfSquaresLocalVelocitySuperposition, LinearLocalVelocitySuperposition\nTurbulence Models: LocalTIModelNoLocalTI, LocalTIModelMaxTI","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The model set can be set up as follows:","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Initialize power model (this is a simple power model based only on turbine design and is not very accurate. For examples on how to use more accurate power models, look at the example optimization scripts)","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"powermodel = ff.PowerModelPowerCurveCubic()","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The user can define different power models for different wind turbines, but here we use the same power model for every turbine. The initialization of the power_models vector is important for optmization using algorithmic differentiation via the ForwardDiff.jl package.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"powermodels = Vector{typeof(powermodel)}(undef, nturbines)\nfor i = 1:nturbines\n    powermodels[i] = powermodel\nend","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Initialize thrust model(s). The user can provide a complete thrust curve. See the example scripts for details on initializing them. The initialization of the ct models vector is important for optmization using algorithmic differentiation via the ForwardDiff.jl package.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"ctmodel = ff.ThrustModelConstantCt(0.65)\nctmodels = Vector{typeof(ctmodel)}(undef, nturbines)\nfor i = 1:nturbines\n    ctmodels[i] = ctmodel\nend","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Set up wake and related models. Here we will use the default values provided in FLOWFarm. However, it is important to use the correct model parameters. More information and references are provided in the doc strings attached to each model.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The wake deficit model predicts the impact of wind turbines wake on the wind speed.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"wakedeficitmodel = ff.GaussYawVariableSpread()","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The wake deflection model predicts the cross-wind location of the center of a wind turbine wake.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"wakedeflectionmodel = ff.GaussYawDeflection()","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The wake combination model defines how the predicted deficits in each wake should be combined to predict the total deficit at a point","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"wakecombinationmodel = ff.LinearLocalVelocitySuperposition()","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The local turbulence intensity models can be used to estimate the local turbulence intensity at each wind turbine or point to provide more accurate input information to the wake and deflection models if applicable.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"localtimodel = ff.LocalTIModelMaxTI()","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Initialize model set. This is just a convenience container for the analysis models.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"modelset = ff.WindFarmModelSet(wakedeficitmodel, wakedeflectionmodel, wakecombinationmodel, localtimodel)\nprintln(\"\") # hide","category":"page"},{"location":"Tutorial/#(3)-Running-the-analysis","page":"Quick Start","title":"(3) Running the analysis","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Now that the wind farm and analysis models have been defined, we can calculate AEP. The output is in Watt-hours.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"aep = ff.calculate_aep(turbinex, turbiney, turbinez, rotordiameter,\n    hubheight, turbineyaw, ctmodels, generatorefficiency, cutinspeed,\n    cutoutspeed, ratedspeed, ratedpower, windresource, powermodels, modelset,\n    rotor_sample_points_y=rotorsamplepointsy, rotor_sample_points_z=rotorsamplepointsz)","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"We can also get the AEP in each direction using the following.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"state_aeps = ff.calculate_state_aeps(turbinex, turbiney, turbinez, rotordiameter,\n        hubheight, turbineyaw, ctmodels, generatorefficiency, cutinspeed,\n        cutoutspeed, ratedspeed, ratedpower, windresource, powermodels, modelset,\n        rotor_sample_points_y=rotorsamplepointsy, rotor_sample_points_z=rotorsamplepointsz, \n        hours_per_year=365.25*24.0, weighted=true)","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"If we instead set weighted=false then we would get the power in each direction in Watts.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"If we want to get the individual turbine powers in each directions, we use the following.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"turbine_powers_by_direction = ff.calculate_state_turbine_powers(turbinex, turbiney, turbinez, rotordiameter,\n    hubheight, turbineyaw, ctmodels, generatorefficiency, cutinspeed,\n    cutoutspeed, ratedspeed, ratedpower, windresource, powermodels, modelset,\n    rotor_sample_points_y=rotorsamplepointsy, rotor_sample_points_z=rotorsamplepointsz)","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The output shows each turbine power in an array that is ndirections by nturbines.","category":"page"},{"location":"Tutorial/#(4)-setting-up-and-running-an-optimization","page":"Quick Start","title":"(4) setting up and running an optimization","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"FLOWFarm is specifically designed for efficient optimization using gradient-based optimization methods. Besides the steps outlined above, we need to define the following before we can run  an optimization:","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"(1) Optimization related variables\n(1) A container for non-differentiated parameters\n(2) Objective function \n(3) Constraint function(s) \n(4) Optimization tool specific items","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"In this tutorial we demonstrate optimizing using the IPOPT algorithms via SNOW.jl for simplicity.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"First, set up optimization related variables. We will have two constraints, one to keep  turbines from getting too close to each other (spacing), and the other to keep turbines  inside the desired area (boundary). FLOWFarm provides several different ways of handling  boundary constraints, including concave boundaries. However, for this tutorial we will use  a simple circular boundary.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# scale objective derivatives to be between 0 and 1\nobjectivescale = 1E-6\n\n# scale boundary constraint derivatives to be between 0 and 1\nconstraintscaleboundary = 1.0E-3\n\n# scale spacing constraint derivatives to be between 0 and 1\nconstraintscalespacing = 1.0\n\n# set the minimum spacing between turbines \nminimumspacing = 160.0\nprintln(\"\") # hide","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Next, set up a container for non-differentiated parameters","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# set up a struct for use in optimization functions\nmutable struct params_struct{}\n    modelset\n    rotorsamplepointsy\n    rotorsamplepointsz\n    turbinez\n    ambientti\n    rotordiameter\n    boundarycenter\n    boundaryradius\n    objectivescale\n    constraintscaleboundary\n    constraintscalespacing\n    minimumspacing\n    hubheight\n    turbineyaw\n    ctmodels\n    generatorefficiency\n    cutinspeed\n    cutoutspeed\n    ratedspeed\n    ratedpower\n    windresource\n    powermodels\nend\n\nparams = params_struct(modelset, rotorsamplepointsy, rotorsamplepointsz, turbinez, ambientti, \n    rotordiameter, boundarycenter, boundaryradius, objectivescale, constraintscaleboundary,\n    constraintscalespacing, minimumspacing, hubheight, turbineyaw, \n    ctmodels, generatorefficiency, cutinspeed, cutoutspeed, ratedspeed, ratedpower, \n    windresource, powermodels)\nprintln(\"\") # hide","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Now we are ready to set up wrapper functions for the objective and constraints.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# set up boundary constraint wrapper function\nfunction boundary_wrapper(x, params)\n    # include relevant params\n    boundarycenter = params.boundarycenter\n    boundaryradius = params.boundaryradius\n    constraintscaleboundary = params.constraintscaleboundary\n\n    # find the number of turbines\n    nturbines = Int(length(x)/2)\n    \n    # extract x and y locations of turbines from design variables vector\n    turbinex = x[1:nturbines]\n    turbiney = x[nturbines+1:end]\n\n    # get and return boundary distances\n    return ff.circle_boundary(boundarycenter, boundaryradius, turbinex, turbiney).*constraintscaleboundary\nend\n\n# set up spacing constraint wrapper function\nfunction spacing_wrapper(x, params)\n    # include relevant params\n    rotordiameter = params.rotordiameter\n    constraintscalespacing = params.constraintscalespacing\n    minimumspacing = params.minimumspacing\n\n    # get number of turbines\n    nturbines = Int(length(x)/2)\n\n    # extract x and y locations of turbines from design variables vector\n    turbinex = x[1:nturbines]\n    turbiney = x[nturbines+1:end]\n\n    # get and return spacing distances\n    return constraintscalespacing.*(minimumspacing .- ff.turbine_spacing(turbinex,turbiney))\nend\n\n# set up aep wrapper function\nfunction aep_wrapper(x, params)\n\n    # include relevant params\n    turbinez = params.turbinez\n    rotordiameter = params.rotordiameter\n    hubheight = params.hubheight\n    turbineyaw =params.turbineyaw\n    ctmodels = params.ctmodels\n    generatorefficiency = params.generatorefficiency\n    cutinspeed = params.cutinspeed\n    cutoutspeed = params.cutoutspeed\n    ratedspeed = params.ratedspeed\n    ratedpower = params.ratedpower\n    windresource = params.windresource\n    powermodels = params.powermodels\n    modelset = params.modelset\n    rotorsamplepointsy = params.rotorsamplepointsy\n    rotorsamplepointsz = params.rotorsamplepointsy\n    objectivescale = params.objectivescale\n\n    # get number of turbines\n    nturbines = Int(length(x)/2)\n\n    # extract x and y locations of turbines from design variables vector\n    turbinex = x[1:nturbines] \n    turbiney = x[nturbines+1:end]\n\n    # calculate AEP\n    aep = objectivescale*ff.calculate_aep(turbinex, turbiney, turbinez, rotordiameter,\n                hubheight, turbineyaw, ctmodels, generatorefficiency, cutinspeed,\n                cutoutspeed, ratedspeed, ratedpower, windresource, powermodels, modelset,\n                rotor_sample_points_y=rotorsamplepointsy,rotor_sample_points_z=rotorsamplepointsz)\n    \n    # return the AEP\n    return aep\nend\n\n# set up optimization problem wrapper function\nfunction wind_farm_opt!(g, x, params)\n\n    nturbines = Int(length(x)/2)\n\n    # calculate spacing constraint value and jacobian\n    spacing_con = spacing_wrapper(x, params)\n\n    # calculate boundary constraint and jacobian\n    boundary_con = boundary_wrapper(x, params)\n\n    # combine constaint values and jacobians into overall constaint value and jacobian arrays\n    g[1:(end-nturbines)] = spacing_con[:]\n    g[end-nturbines+1:end] = boundary_con[:]\n    \n    # calculate the objective function and jacobian (negative sign in order to maximize AEP)\n    obj = -aep_wrapper(x, params)[1]\n    \n    return obj\nend\nprintln(\"\") # hide","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Because the optimizer will need to call the objective function without knowing about the params, we need to set up a method that will know the params values by default.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# generate objective function wrapper\nobj_func!(g, x) = wind_farm_opt!(g, x, params)","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Next we set up the optimizer.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# initialize design variable vector\nx0 = [copy(turbinex);copy(turbiney)]\n\n# set general lower and upper bounds for design variables\nlx = zeros(length(x0)) .- boundaryradius\nux = zeros(length(x0)) .+ boundaryradius\n\n# set general lower and upper bounds for constraints\nng = Int(nturbines + (nturbines)*(nturbines - 1)/2)\nlg = [-Inf*ones(Int((nturbines)*(nturbines - 1)/2)); -Inf*ones(nturbines)]\nug = [zeros(Int((nturbines)*(nturbines - 1)/2)); zeros(nturbines)]\n\n# IPOPT options\nip_options = Dict(\n    \"max_iter\" => 50,\n    \"tol\" => 1e-6\n)\nsolver = IPOPT(ip_options)\n\n# if using SNOPT, you can do the following instead:\n# snopt_opt = Dict(\n#    \"Derivative option\" => 1,\n#    \"Major optimality tolerance\" => 1e-4,\n# )\n# solver = SNOPT(options=snopt_opt)\n\n# initialize SNOW options\noptions = Options(solver=solver, derivatives=ForwardAD())  # choose AD derivatives\nprintln(\"\") # hide","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Now that the optimizer is set up, we are ready to optimize and check the results.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# optimize\nt1 = time() # start time\nxopt, fopt, info, out = minimize(obj_func!, x0, ng, lx, ux, lg, ug, options)\nt2 = time() # end time\nclk = t2-t1 # approximate run time\n\n# get final aep\naepfinal = -fopt/objectivescale\n\n# print optimization results \nprintln(\"Finished in : \", clk, \" (s)\")\nprintln(\"info: \", info)\nprintln(\"Initial AEP: \", aep)\nprintln(\"Final AEP: \", aepfinal)\nprintln(\"AEP improvement (%) = \", 100*(aepfinal - aep)/aep) \n\n# extract final turbine locations\nturbinexopt = copy(xopt[1:nturbines])\nturbineyopt = copy(xopt[nturbines+1:end])","category":"page"},{"location":"Tutorial/#(5)-Calculating-a-flow-field","page":"Quick Start","title":"(5) Calculating a flow field","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"It is helpful to visualize the whole flow-field, not just the turbine powers.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"# define how many points should be in the flow field\nxres = 1000\nyres = 1000\nzres = 1\n\n# define flow field domain\nmaxy = boundaryradius*1.5\nminy = -boundaryradius*1.5\nmaxx = boundaryradius*1.5\nminx = -boundaryradius*1.5\n\n# set up point grid for flow field\nxrange = minx:(maxx-minx)/xres:maxx\nyrange = miny:(maxy-miny)/yres:maxy\nzrange = hubheight[1]\n\n# run flowfarm \nffvelocities = ff.calculate_flow_field(xrange, yrange, zrange,\n    modelset, turbinexopt, turbineyopt, turbinez, turbineyaw,\n    rotordiameter, hubheight, ctmodels, rotorsamplepointsy, rotorsamplepointsz,\n    windresource, wind_farm_state_id=5)\n","category":"page"},{"location":"WindFarmStruct/#Wind-Farm-Struct","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"","category":"section"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"This tutorial covers the usage of the wind farm struct. The wind farm struct simplifies optimization set up and allows for the use of sparse methods in gradient calculation. The AEP value and the gradient are both stored in the farm struct","category":"page"},{"location":"WindFarmStruct/#Farm-Struct","page":"Wind Farm Struct","title":"Farm Struct","text":"","category":"section"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"All of the setup from the previous tutorial sections 1 and 2 is required. Then the wind farm struct in defined.","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"function my_update_function(farm,x)\n    farm.turbine_x .= x[1:length(x)÷2]\n    farm.turbine_y .= x[length(x)÷2+1:end]\nend\n\nfarm = ff.build_wind_farm_struct(x0, x, y, turbine_z, hub_height, turbine_yaw, rotor_diameter, ct_models, generator_efficiency, cut_in_speed, cut_out_speed, rated_speed, rated_power, windresource, power_models, model_set, my_update_function; AEP_scale=1.0, input_type=\"ForwardDiff\", opt_x=true, opt_y=true)","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"buildwindfarm_struct has many inputs and options. While most are well defined in the previous tutorial, some are new. ","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"x0 is a vector of the design variables and should already be scaled. \nmy_update_function is a function that is of the form f(wind_farm_struct, design_variables) and updates the wind farm struct in place from the design variables.\nAEP_scale applies a scale factor to the AEP calculation and by default uses 1.0/ideal_AEP.\ninput_type is FowardDiff when using the farm struct for optimization. Otherwise, deafults to nothing and will use the type of x0\nopt_x, opt_y, opt_hub, opt_yaw, and opt_diam determine which variables are being optimized so that only those variables are stored as input_type. This allows for faster gradient computation.","category":"page"},{"location":"WindFarmStruct/#Constraint-Structs","page":"Wind Farm Struct","title":"Constraint Structs","text":"","category":"section"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"Constraint structs are also provided for both spacing and boundary constraints.","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"spacing = 2.0 * rotor_diameter[1] # 2 rotor diameters spacing between turbines\nscaling = 1.0/rotor_diameter[1]^2 # scaling factor for spacing constraint\nspacing_struct = ff.build_spacing_struct(x0, num_turbines, spacing, scaling, my_update_function)\n\nboundary_function(a,x,y) = ff.circle_boundary!(a, boundary_center, boundary_radius, x, y) # boundary function, must be in-place and take the form f(a,x,y) where a is the constraint values\nn_constraints = num_turbines # number of boundary constraints\nscaling = 1.0/boundary_radius^2 # scaling factor for boundary constraint\nboundary_struct = ff.build_boundary_struct(x0, num_turbines, n_constraints, scaling, boundary_function, my_update_function)","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"The resulting objective function then looks like:","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"function opt!(g,df,dg,x,farm,spacing_struct,boundary_struct)\n\n    # calculate spacing constraint value and jacobian\n    ff.calculate_spacing_jacobian!(spacing_struct,x)\n\n    # calculate boundary constraint and jacobian\n    ff.calculate_boundary_jacobian!(boundary_struct,x)\n\n    # combine constaint values and jacobians into overall constaint value and jacobian arrays\n    c = [spacing_struct.spacing_vec; boundary_struct.boundary_vec]\n    g[:] .= ((c[:]))\n    dg[:] = (([spacing_struct.jacobian; boundary_struct.jacobian]))\n\n    # calculate AEP and gradient\n    ff.calculate_aep_gradient!(farm,x)\n\n    AEP = -farm.AEP[1]\n    df[:] .= ((-farm.AEP_gradient))\n\n    return AEP\nend\n\n# Force signature to allow for pass into SNOW.minimize\nopt!(g,df,dg,x) = opt!(g,df,dg,x,farm,spacing_struct,boundary_struct)","category":"page"},{"location":"WindFarmStruct/#Sparsity-Options","page":"Wind Farm Struct","title":"Sparsity Options","text":"","category":"section"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"Using sparsity can greatly accelerate wind farm optimization. For detailed theory please see","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"Varela, B., and Ning, A., “Sparsity Applications for Gradient-Based Optimization of Wind Farms,” Oct. 2024, (in review).","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"The use of sparsity is built into FLOWFarm for user convenience.","category":"page"},{"location":"WindFarmStruct/#Farm-Sparsity","page":"Wind Farm Struct","title":"Farm Sparsity","text":"","category":"section"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"There are two types of sparsity used in calculating the gradient of the AEP, stable and unstable sparsity. Stable sparsity refers to the situation where the sparsity pattern does not change during the optimization. Unstable sparsity refers to situations where the sparsity pattern may change during the optimzation. The sparsity pattern referred to depends on how each turbine affects the power produced by every other turbine due to its wake interference. ","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"For example, any optimization where the x or y positions of the turbines are design variables will result in changing sparsity patterns as the turbines move and interact with different turbines. In contrast a yaw optimization is unlikely to cause a change in the sparsity pattern during the optimization.","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"Use of sparsity in AEP optimization requires a sparse_struct that must be passed into the objective function in the same manner as constraint structs. The AEP and the AEP gradient are then stored in the farm struct just as with non-sparse methods","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"ff.calculate_aep_gradient!(farm,x0,sparse_struct)\nprintln(\"AEP = \",farm.AEP[1])\nprintln(\"AEP Gradient = \",farm.AEP_gradient)","category":"page"},{"location":"WindFarmStruct/#Stable-Sparsity","page":"Wind Farm Struct","title":"Stable Sparsity","text":"","category":"section"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"Stable sparse farm structs are constructed in a similar method to regular farm structs","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"farm, sparse_struct = ff.build_stable_sparse_struct(x0, x, y, turbine_z, hub_height, turbine_yaw, rotor_diameter, ct_models, generator_efficiency, cut_in_speed, cut_out_speed, rated_speed, rated_power, windresource, power_models, model_set, my_update_function_yaw; AEP_scale=1.0, opt_yaw=true, tolerance=1E-16)","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"The only new parameter is tolerance which defaults to 1E-16. This tolerance is used when computing the sparsity pattern. When creating the sparse_struct the sparsity pattern is computed by calculating the partial derivatives of the power of each turbine with respect to each design variable. Then, all partial derivatives with a magnitude below the tolerance are ignored in the sparsity pattern. The default value is safe for almost all cases and the effect of the tolerance is explored more in the above paper. ","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"Important note: build_stable_sparse_struct attempts to calculate an accurate sparsity pattern by perturbing all of the design variables randomly to avoid poor starting locations where derivatives zero out, such as in yaw optimization when the turbine faces directly into the wind. While this does help get an accurate sparsity pattern it is advised to call build_stable_sparse_struct with x0 set to a reasonable start point to avoid derivatives that are not representative of the influence of the design variable.","category":"page"},{"location":"WindFarmStruct/#Unstable-Sparsity","page":"Wind Farm Struct","title":"Unstable Sparsity","text":"","category":"section"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"Unstable sparse methods can always be used as the sparsity pattern is recomputed at each iteration using the wake deficits from the AEP calculation, but unstable sparse methods are not as efficient as stable sparse methods, again see the theory paper.","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"Unstable sparse structs are computed in the same way as stable sparse struct with a different function call.","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"farm, sparse_struct = ff.build_unstable_sparse_struct(x0, x, y, turbine_z, hub_height, turbine_yaw, rotor_diameter, ct_models, generator_efficiency, cut_in_speed, cut_out_speed, rated_speed, rated_power, windresource, power_models, model_set, my_update_function_yaw; AEP_scale=1.0, opt_yaw=true, tolerance=1E-16)","category":"page"},{"location":"WindFarmStruct/#Constraint-Sparsity","page":"Wind Farm Struct","title":"Constraint Sparsity","text":"","category":"section"},{"location":"WindFarmStruct/#Boundary-Constraints","page":"Wind Farm Struct","title":"Boundary Constraints","text":"","category":"section"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"The boundary constraint structs use sparsity by default as it has not effect on the solutions and little effect on the computation speed. This can be turned off with using_sparsity=false.","category":"page"},{"location":"WindFarmStruct/#Spacing-Constraints","page":"Wind Farm Struct","title":"Spacing Constraints","text":"","category":"section"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"The use of sparsity in spacing constraints is more complicated than with the farm AEP and requires at least 2 optimizations. First an optimization is performed with no spacing constraints, then a second optimization is performed with select spacing constraints.","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"The function call for building a sprase spacing struct is","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"sparse_spacing_struct = ff.build_sparse_spacing_struct(x0, x, y, spacing, scaling, spacing_update_function!; first_opt=true, relevant_spacing_factor=2)\n\nff.calculate_spacing_jacobian!(sparse_spacing_struct,x)","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"first_opt defaults to true and causes no spacing constraints to be calculated, resulting in empty spacing jacobian and spacing constraints objects. This is done to allow the objective function to remain unchanged between the first and second optimizations. first_opt should be set to false when creating the spacing struct for the second optimization relevant_spacing_factor defaults to 2 and determines which spacing constraints are relevant during the optimization by only including constraints where turbine pairs are within spacing * relevant_spacing_factor from eachother. These constraints are determined based on the x and y passed into the build function.","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"By using no spacing constraints in the first optimization the design space is freed from many constraints, causing the solution to be improved and reached faster. The second optimization is then short as an optimum has been reached and only a small number of spacing constraints must be satisfied. This works well, but depending on your optimizer the second optimization can be difficult if started from a position that violates constraints. To ease this sparse spacing structs can store the last position that satisfied all the spacing constraints during the first optimization. ","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"ff.update_safe_design_variables!(sparse_spacing_struct,x)","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"spacing_struct.safe_design_variables can then be used as the start point for the second optimization.","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"The computing of the spacing constraints during the first optimization to determine if any are violated is minimal as the speed up of the optimization is caused by the optimizer having less constraints to satisfy.","category":"page"},{"location":"WindFarmStruct/#Sparse-Objective-Function-in-SNOW","page":"Wind Farm Struct","title":"Sparse Objective Function in SNOW","text":"","category":"section"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"When giving constraints to SNOW.jl it is possible to give the optimizer a sparse set of constaints whether or not the sparse structs are used. This is shown in the following using sp. ","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"function opt!(g,df,dg,x,farm,spacing_struct,boundary_struct,sp,sparse_struct)\n\n    ff.update_safe_design_variables!(spacing_struct,x)\n\n    # calculate spacing constraint value and jacobian\n    ff.calculate_spacing_jacobian!(spacing_struct,x)\n\n    # calculate boundary constraint and jacobian\n    ff.calculate_boundary_jacobian!(boundary_struct,x)\n\n    # combine constaint values and jacobians into overall constaint value and jacobian arrays\n    c = [spacing_struct.spacing_vec; boundary_struct.boundary_vec]\n    g[:] .= ((c[:]))\n\n    dcdx = (sparse([spacing_struct.jacobian; boundary_struct.jacobian]))\n    for i = 1:length(sp.rows)\n        dg[i] = dcdx[sp.rows[i],sp.cols[i]]\n    end\n\n    # calculate the objective function and jacobian (negative sign in order to maximize AEP)\n    ff.calculate_aep_gradient!(farm,x,sparse_struct)\n\n    AEP = -farm.AEP[1]\n\n    df[:] .= ((-farm.AEP_gradient))\n\n    return AEP\nend","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"sp is calculated as follows assuming that the constraint jacobians have already been calculated.","category":"page"},{"location":"WindFarmStruct/","page":"Wind Farm Struct","title":"Wind Farm Struct","text":"sp = SNOW.SparsePattern(sparse(dropzeros(vcat(spacing_struct.jacobian,boundary_struct.jacobian))))","category":"page"},{"location":"Explanation/#Explanation","page":"Theory","title":"Explanation","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"This section consists primarily of citations of relevant papers where details about each  model can be found. It is admittedly incomplete, but will hopefully be expanded over time.","category":"page"},{"location":"Explanation/#Wake-Deficit-Models","page":"Theory","title":"Wake Deficit Models","text":"","category":"section"},{"location":"Explanation/#Jensen","page":"Theory","title":"Jensen","text":"","category":"section"},{"location":"Explanation/#JensenTopHat","page":"Theory","title":"JensenTopHat","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[1] N. O. Jensen. A note on wind generator interaction. Technical report, Risø National Laboratory, DK-4000 Roskilde, Denmark, November 1983.","category":"page"},{"location":"Explanation/#JensenCosine","page":"Theory","title":"JensenCosine","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[1] N. O. Jensen. A note on wind generator interaction. Technical report, Risø National Laboratory, DK-4000 Roskilde, Denmark, November 1983.\n[2] J. J. Thomas, S. McOmber, and A. Ning. Wake expansion continuation: Multi-modality reduction in the wind farm layout optimization problem. Wind Energy, May 2021. (in review).","category":"page"},{"location":"Explanation/#MultiZone","page":"Theory","title":"MultiZone","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"Simply put, three jensen top-hat models stacked on top of each other to approximate varrying behavior in different wake zones.","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[3] P. M. O. Gebraad, F. W. Teeuwisse, J. W. van Wingerden, P. A. Fleming, S. D. Ruben, J. R. Marden, and L. Y. Pao. Wind plant power optimization through yaw control using a parametric model for wake effects—a CFD simulation study. Wind Energy, 2014.","category":"page"},{"location":"Explanation/#Gaussian","page":"Theory","title":"Gaussian","text":"","category":"section"},{"location":"Explanation/#GaussOriginal","page":"Theory","title":"GaussOriginal","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[4] M. Bastankhah and F. Port ́e-Agel. A new analytical model for wind-turbine wakes. Renewable Energy, 70:116–123, 2014.","category":"page"},{"location":"Explanation/#GaussYaw","page":"Theory","title":"GaussYaw","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[5] M. Bastankhah and F. Port ́e-Agel. Experimental and theoretical study of wind turbine wakes in yawed conditions. Journal of Fluid Mechanics, 806:506–541, 2016.","category":"page"},{"location":"Explanation/#GaussYawVariableSpread","page":"Theory","title":"GaussYawVariableSpread","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[5] M. Bastankhah and F. Port ́e-Agel. Experimental and theoretical study of wind turbine wakes in yawed conditions. Journal of Fluid Mechanics, 806:506–541, 2016.\n[6] A. Niayifar and F. Port ́e-Agel. Analytical modeling of wind farms: A new approach for power prediction. Energies, 9(9):1–13, 2016.","category":"page"},{"location":"Explanation/#GaussSimple","page":"Theory","title":"GaussSimple","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[7] N. F. Baker, A. P. J. Stanley, J. J. Thomas, A. Ning, and K. Dykes. Best practices for wake model and optimization algorithm selection in wind farm layout optimization. In AIAA Scitech 2019 Forum, San Diego, CA, Jan. 2019.","category":"page"},{"location":"Explanation/#Wake-Deflection-Models","page":"Theory","title":"Wake Deflection Models","text":"","category":"section"},{"location":"Explanation/#Jimenez","page":"Theory","title":"Jimenez","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[8] A ́. Jim ́enez, A. Crespo, and E. Migoya. Application of a LES technique to chracterize the wake deflection of a wind turbine in yaw. Wind Energy, 13:559–572, 2010.","category":"page"},{"location":"Explanation/#MultiZone-2","page":"Theory","title":"MultiZone","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[3] P. M. O. Gebraad, F. W. Teeuwisse, J. W. van Wingerden, P. A. Fleming, S. D. Ruben, J. R. Marden, and L. Y. Pao. Wind plant power optimization through yaw control using a parametric model for wake effects—a CFD simulation study. Wind Energy, 2014.\n[9] J. Thomas, P. Gebraad, and A. Ning. Improving the FLORIS wind plant model for compatibility with gradient-based optimization. Wind Engineering, Aug. 2017.","category":"page"},{"location":"Explanation/#Gauss","page":"Theory","title":"Gauss","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[5] M. Bastankhah and F. Port ́e-Agel. Experimental and theoretical study of wind turbine wakes in yawed conditions. Journal of Fluid Mechanics, 806:506–541, 2016.","category":"page"},{"location":"Explanation/#Wake-Combination-Models","page":"Theory","title":"Wake Combination Models","text":"","category":"section"},{"location":"Explanation/#LinearFreestreamSuperposition","page":"Theory","title":"LinearFreestreamSuperposition","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[10] P. Lissaman. Energy effectiveness of arbitrary arrays of wind turbines. Journal of Energy, 3:323–328, 1979.","category":"page"},{"location":"Explanation/#SumOfSquaresFreestreamSuperposition","page":"Theory","title":"SumOfSquaresFreestreamSuperposition","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[11] I. Katic, J. Højstrup, and N. Jensen. A simple model for cluster efficiency. In European Wind Energy Association Conference and Exhibition, Rome - Italy, October 1986. European Wind Energy Association.","category":"page"},{"location":"Explanation/#SumOfSquaresLocalVelocitySuperposition","page":"Theory","title":"SumOfSquaresLocalVelocitySuperposition","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[12] S. Voutsinas, K. Rados, and A. Zervos. On the analysis of wake effects in wind parks. Wind Engineering, 14:204–2019, 1990.","category":"page"},{"location":"Explanation/#LinearLocalVelocitySuperposition","page":"Theory","title":"LinearLocalVelocitySuperposition","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[6] A. Niayifar and F. Port ́e-Agel. Analytical modeling of wind farms: A new approach for power prediction. Energies, 9(9):1–13, 2016.","category":"page"},{"location":"Explanation/#Local-Turbulence-Intensity-Models","page":"Theory","title":"Local Turbulence Intensity Models","text":"","category":"section"},{"location":"Explanation/#LocalTIModelNoLocalTI","page":"Theory","title":"LocalTIModelNoLocalTI","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"Just like it sounds. Local TI is ignored and ambient TI is used anywhere TI is called for in the calculations.","category":"page"},{"location":"Explanation/#LocalTIModelMaxTI","page":"Theory","title":"LocalTIModelMaxTI","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[6] A. Niayifar and F. Port ́e-Agel. Analytical modeling of wind farms: A new approach for power prediction. Energies, 9(9):1–13, 2016.s","category":"page"},{"location":"Explanation/#GaussianTI","page":"Theory","title":"GaussianTI","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"Not currently connected with the general wind farm models, but it hopefully will be eventually.","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[13] A. Pen ̃a, K. Schaldemose Hansen, S. Ott, and M. P. van der Laan. On wake modeling, wind-farm gradients, and aep predictions at the anholt wind farm. Wind Energy Science, 3(1):191–202, 2018.","category":"page"},{"location":"Explanation/#Wake-Expansion-Continuation-(WEC)","page":"Theory","title":"Wake Expansion Continuation (WEC)","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[2] J. J. Thomas, S. McOmber, and A. Ning. Wake expansion continuation: Multi-modality reduction in the wind farm layout optimization problem. Wind Energy, May 2021. (in review).","category":"page"},{"location":"Explanation/#Sparsity-in-Wind-Farm-Optimization","page":"Theory","title":"Sparsity in Wind Farm Optimization","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[14] Varela, B., and Ning, A., “Sparsity Applications for Gradient-Based Optimization of Wind Farms,” Oct. 2024, (in review).","category":"page"},{"location":"Explanation/#Wind-Shear","page":"Theory","title":"Wind Shear","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"Wind shear refers to the fact that the wind speed changes with elevation. For wind farms, that change is due to the boundary layer of the wind flowing over the earth. The boundary layer is the region where the flow transitions from stationary at the ground, to some free-stream speed at some distance above the ground. ","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"Wind shear in FLOWFarm is handled using a power law","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"u = u_r bigfracz-z_0z_r-z_0big^phi","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"where u is the wind speed at the desired height (z), z_r is the height of the known speed (u_r), and z_0 is the height of the ground (which is zero for flat terrain). The value of phi controls how quickly the wind speed transitions from zero to the free-stream velocity.","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"The models used by FLOWFarm are simple engineering models and do not account for wind shear. To apply wind shear, we first adjust the inflow speed using the wind shear equation and then apply the wake deficit for the given point. ","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"using FLOWFarm; const ff = FLOWFarm\n\n# set input values\nshear_exponent = 0.15\nlocz = 40.0 # height above ground in meters\nreference_velocity = 8.0 # in m/s\nreference_height = 80.0 # height of reference velocity in meters\nground_height = 0.0 # height where velocity goes to zero\n\n# initialize wind shear model instance\nwind_shear_model = ff.PowerLawWindShear(shear_exponent)\n\n# adjust wind speed for wind shear\nff.adjust_for_wind_shear(locz, reference_velocity, reference_height, ground_height, wind_shear_model)\n\n# output\n7.2100037008866416","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"Citing:","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"[1] N. O. Jensen. A note on wind generator interaction. Technical report, Risø National Laboratory, DK-4000 Roskilde, Denmark, November 1983.\n[2] J. J. Thomas, S. McOmber, and A. Ning. Wake expansion continuation: Multi-modality reduction in the wind farm layout optimization problem. Wind Energy, May 2021. (in review).\n[3] P. M. O. Gebraad, F. W. Teeuwisse, J. W. van Wingerden, P. A. Fleming, S. D. Ruben, J. R. Marden, and L. Y. Pao. Wind plant power optimization through yaw control using a parametric model for wake effects—a CFD simulation study. Wind Energy, 2014.\n[4] M. Bastankhah and F. Port ́e-Agel. A new analytical model for wind-turbine wakes. Renewable Energy, 70:116–123, 2014.\n[5] M. Bastankhah and F. Port ́e-Agel. Experimental and theoretical study of wind turbine wakes in yawed conditions. Journal of Fluid Mechanics, 806:506–541, 2016.\n[6] A. Niayifar and F. Port ́e-Agel. Analytical modeling of wind farms: A new approach for power prediction. Energies, 9(9):1–13, 2016.\n[7] N. F. Baker, A. P. J. Stanley, J. J. Thomas, A. Ning, and K. Dykes. Best practices for wake model and optimization algorithm selection in wind farm layout optimization. In AIAA Scitech 2019 Forum, San Diego, CA, Jan. 2019.\n[8] A ́. Jim ́enez, A. Crespo, and E. Migoya. Application of a LES technique to chracterize the wake deflection of a wind turbine in yaw. Wind Energy, 13:559–572, 2010.\n[9] J. Thomas, P. Gebraad, and A. Ning. Improving the FLORIS wind plant model for compatibility with gradient-based optimization. Wind Engineering, Aug. 2017.\n[10] P. Lissaman. Energy effectiveness of arbitrary arrays of wind turbines. Journal of Energy, 3:323–328, 1979.\n[11] I. Katic, J. Højstrup, and N. Jensen. A simple model for cluster efficiency. In European Wind Energy Association \n[12] S. Voutsinas, K. Rados, and A. Zervos. On the analysis of wake effects in wind parks. Wind Engineering, 14:204–2019, 1990.\n[13] A. Pen ̃a, K. Schaldemose Hansen, S. Ott, and M. P. van der Laan. On wake modeling, wind-farm gradients, and aep predictions at the anholt wind farm. Wind Energy Science, 3(1):191–202, 2018.\n[14] Varela, B., and Ning, A., “Sparsity Applications for Gradient-Based Optimization of Wind Farms,” Oct. 2024, (in review).","category":"page"},{"location":"#FLOWFarm.jl","page":"Intro","title":"FLOWFarm.jl","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Summary: Wind farm simulation tool for gradient-based optimization.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Authors: Jared J. Thomas, Andrew P.J. Stanley","category":"page"},{"location":"#Features","page":"Intro","title":"Features","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Swap out models without changing anything else in the simulation setup\nSmooth/continous model implementations\nRuns on a single core, across multiple cores (threaded), or on multiple machines (distributed).\nDesigned so that new model implementations can be included by adding a single method\nAllows for Wake Expansion Continuation (WEC) as described here","category":"page"},{"location":"#Installation","page":"Intro","title":"Installation","text":"","category":"section"},{"location":"#Install-FLOWFarm","page":"Intro","title":"Install FLOWFarm","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"julia\n(v1.x) pkg> dev https://github.com/byuflowlab/FLOWFarm.jl.git","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Begin with the quick start tutorial.\nMore advanced topics are covered in the how-to guide.\nTheory details, and links, can be found in the theory page.\nDoc strings can be found in the references page.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Citing: Thomas, McOmber, and Ning \"Wake Expansion Continuation: Multi-Modality Reduction in the Wind Farm Layout Optimization Problem\" Wind Energy (in review), –>","category":"page"}]
}
