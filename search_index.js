var documenterSearchIndex = {"docs":
[{"location":"How_to/#How-to-Guide","page":"Guided Examples","title":"How-to Guide","text":"","category":"section"},{"location":"How_to/#Multi-threading","page":"Guided Examples","title":"Multi-threading","text":"","category":"section"},{"location":"How_to/","page":"Guided Examples","title":"Guided Examples","text":"Multi-threading is available for the calculation of annual energy production (AEP). It can be enabled as follows in a bash terminal in Linux/OS prior to launching a julia session:","category":"page"},{"location":"How_to/","page":"Guided Examples","title":"Guided Examples","text":"export JULIA_NUM_THREADS=<number of threads>","category":"page"},{"location":"How_to/","page":"Guided Examples","title":"Guided Examples","text":"For enabling multi-threading on other shells/systems please see the julia parallel-computing docs here: https://docs.julialang.org/en/v1/manual/parallel-computing/.","category":"page"},{"location":"How_to/#Distributed-Processing","page":"Guided Examples","title":"Distributed Processing","text":"","category":"section"},{"location":"How_to/","page":"Guided Examples","title":"Guided Examples","text":"Distributed parallel processing is available for the calculation of annual energy production (AEP). ","category":"page"},{"location":"How_to/","page":"Guided Examples","title":"Guided Examples","text":"You may have to add using Distributed to your julia script and use the @everywhere macro  in front of any functions you define that all processors will need access to. For an example,  see example_opt_6_38turb_round_distributed.jl.","category":"page"},{"location":"How_to/#Using-Distributed-Processing-without-an-HPC-Cluster-Manager-(e.g.-on-your-local-system)","page":"Guided Examples","title":"Using Distributed Processing without an HPC Cluster Manager (e.g. on your local system)","text":"","category":"section"},{"location":"How_to/","page":"Guided Examples","title":"Guided Examples","text":"Distributed parallel processing can be enabled as follows when launching a julia session:","category":"page"},{"location":"How_to/","page":"Guided Examples","title":"Guided Examples","text":"julia -p <number of processors>","category":"page"},{"location":"How_to/#Using-Distributed-Processing-with-an-HPC-Cluster-Manager-(e.g.-SLURM)","page":"Guided Examples","title":"Using Distributed Processing with an HPC Cluster Manager (e.g. SLURM)","text":"","category":"section"},{"location":"How_to/","page":"Guided Examples","title":"Guided Examples","text":"The -p option to the julia call is unnecessary when running with a cluster manager.  To work with cluster managers, add the following to your julia script (this example is for  SLURM, but other managers are available as well):","category":"page"},{"location":"How_to/","page":"Guided Examples","title":"Guided Examples","text":"using Distributed\nusing ClusterManagers\n\naddprocs(SlurmManager(parse(Int, ENV[\"SLURM_NTASKS\"])-1))\n@everywhere import FLOWFarm; const ff = FLOWFarm","category":"page"},{"location":"How_to/","page":"Guided Examples","title":"Guided Examples","text":"Also include the @everywhere macro in front of any function definitions or include statements in your julia script that all processors will need access to.","category":"page"},{"location":"How_to/","page":"Guided Examples","title":"Guided Examples","text":"Your SLURM job script should look something like this:","category":"page"},{"location":"How_to/","page":"Guided Examples","title":"Guided Examples","text":"#!/bin/bash -l\n#SBATCH --ntasks=100\n#SBATCH --mem-per-cpu=1024M   # memory per CPU core\n#SBATCH --time=01:00:00 # time=HH:MM:SS\n#SBATCH -J \"Your job name here\"   # job name\n\nmodule load julia\n\njulia julia_script.jl","category":"page"},{"location":"How_to/","page":"Guided Examples","title":"Guided Examples","text":"References For more information on using julia in a distributed environment, please see https://docs.julialang.org/en/v1/manual/parallel-computing/.","category":"page"},{"location":"Reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"Reference/","page":"Reference","title":"Reference","text":"Modules = [FLOWFarm]","category":"page"},{"location":"Reference/#FLOWFarm.DiscretizedWindResource","page":"Reference","title":"FLOWFarm.DiscretizedWindResource","text":"DiscritizedWindResource(wind_directions, wind_speeds, wind_probabilities, measurement_heights, air_density, ti_model, wind_shear_model)\n\nStruct defining a wind resource\n\nArguments\n\nwind_directions::Array{Float,1}(Nstates): an array of wind directions corresponding to each wind farm state in radians\nwind_speeds::Array{Float,1}(Nstates): an array of wind speeds corresponding to each wind farm state in meters/second\nwind_probabilities::Array{Float,1}(Nstates): an array of probabilities corresponding to each wind farm state with values in [0,1]\nmeasurement_heights::Array{Float,1}(Nstates): an array of measurement heights corresponding to each wind farm state\nair_density::Float: the air density\nambient_ti::Array{Float,1}: an array of the ambient turbulence intensity for each wind direction\nwind_shear_model::Array{AbstractWindShearModel}(1): contains a struct defining the desired turbulence intensity model\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.GaussOriginal","page":"Reference","title":"FLOWFarm.GaussOriginal","text":"GaussOriginal(k_star)\n\nContainer for parameters related to the origina Gaussian deficit model presented by Bastankhah and Porte-Agel 2014\n\nArguments\n\nk_star::Float: parameter controlling the wake spreading rate and deficit decay. Default value is 0.075\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.GaussSimple","page":"Reference","title":"FLOWFarm.GaussSimple","text":"GaussSimple(k, wec_factor)\n\nContainer for parameters related to the Gaussian deficit model with yaw presented by Bastankhah and Porte-Agel 2016\n\nArguments\n\nk::Float: parameter controlling the spread of the wake\nwec_factor::Array{Float}: parameter artificial wake spreading for wake expansion continuation (WEC) optimization\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.GaussYaw","page":"Reference","title":"FLOWFarm.GaussYaw","text":"GaussYaw(turbulence_intensity, horizontal_spread_rate, vertical_spread_rate, alpha_star, beta_star)\n\nContainer for parameters related to the Gaussian deficit model with yaw presented by Bastankhah and Porte-Agel 2016\n\nArguments\n\nhorizontal_spread_rate::Float: parameter controlling the horizontal spread of the deficit model. Default value is 0.022.\nvertical_spread_rate::Float: parameter controlling the vertical spread of the deficit model. Default value is 0.022.\nalpha_star::Float: parameter controlling the impact of turbulence intensity on the length of the near wake. Default value is 2.32.\nbeta_star::Float: parameter controlling the impact of the thrust coefficient on the length of the near wake. Default value is 0.154.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.GaussYawDeflection","page":"Reference","title":"FLOWFarm.GaussYawDeflection","text":"GaussYawDeflection(horizontal_spread_rate, vertical_spread_rate, alpha_star, beta_star)\n\nContainer for parameters related to the Gaussian deflection model presented by Bastankhah and Porte-Agel 2016\n\nArguments\n\nhorizontal_spread_rate::Float: parameter controlling the horizontal spread of the deficit model. Default value is 0.022.\nvertical_spread_rate::Float: parameter controlling the vertical spread of the deficit model. Default value is 0.022.\nalpha_star::Float: parameter controlling the impact of turbulence intensity on the length of the near wake. Default value is 2.32.\nbeta_star::Float: parameter controlling the impact of the thrust coefficient on the length of the near wake. Default value is 0.154.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.GaussYawVariableSpread","page":"Reference","title":"FLOWFarm.GaussYawVariableSpread","text":"GaussYawVariableSpread(turbulence_intensity, horizontal_spread_rate, vertical_spread_rate, alpha_star, beta_star)\n\nContainer for parameters related to the Gaussian deficit model with yaw presented by Bastankhah and Porte-Agel 2016     and the farm model presented by Niayifar and Porte-Agel in 2016.\n\nArguments\n\nalpha_star::Float: parameter controlling the impact of turbulence intensity on the length of the near wake. Default value is 2.32.\nbeta_star::Float: parameter controlling the impact of the thrust coefficient on the length of the near wake. Default value is 0.154.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.GaussYawVariableSpreadDeflection","page":"Reference","title":"FLOWFarm.GaussYawVariableSpreadDeflection","text":"GaussYawDeflectionVariableSpread(alpha_star, beta_star, k1, k2, wec_factor)\n\nContainer for parameters related to the Gaussian deflection model with yaw presented by Bastankhah and Porte-Agel 2016\n\nArguments\n\nalpha_star::Float: parameter controlling the impact of turbulence intensity on the length of the near wake. Default value is 2.32.\nbeta_star::Float: parameter controlling the impact of the thrust coefficient on the length of the near wake. Default value is 0.154.\nk1::Float: first parameter tuning wake spread as based on turbulence intensity\nk2::Float: second parameter tuning wake spread as based on turbulence intensity\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.JensenCosine","page":"Reference","title":"FLOWFarm.JensenCosine","text":"JensenCosine(alpha)\n\nContainer for parameters related to the Jensen Cosine deficit model\n\nArguments\n\nalpha::Float: parameter controlling the wake deficit decay rate. Default value is 0.1\nbeta::Float: parameter controlling the width of the cosine function. Default value is 20.0 deg., given in radians.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.JensenTopHat","page":"Reference","title":"FLOWFarm.JensenTopHat","text":"JensenTopHat(alpha)\n\nContainer for parameters related to the Jensen Top Hat deficit model\n\nArguments\n\nalpha::Float: parameter controlling the wake spreading rate and deficit decay. Default value is 0.1\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.JiminezYawDeflection","page":"Reference","title":"FLOWFarm.JiminezYawDeflection","text":"JiminezYawDeflection(horizontal_spread_rate)\n\nContainer for parameters related to the Jiminez deflection model\n\nArguments\n\nhorizontal_spread_rate::Float: parameter controlling the wake spreading rate and deficit decay. Default value is 0.1\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.Levelized","page":"Reference","title":"FLOWFarm.Levelized","text":"Levelized(TCC, BOS, FC, FCR, OpEx)\n\nContainer for parameters related to the Levelized Cost of Energy model (NREL 2016 Cost of Wind Energy)\n\nArguments\n\nArguments\n\nTCC::Float: Turbine Capital Cost not including the tower module\nBOS::Float: Balance of System (Costs outside of turbine i.e. operation and maintenance)\nFC::Float: Financial Costs including construction and contingency\nFCR::Float: Fixed Charge Rate\nOpEx::Float: Operational Expenditures\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.LocalTIModelMaxTI","page":"Reference","title":"FLOWFarm.LocalTIModelMaxTI","text":"LocalTIModelMaxTI(astar, bstar, k1, k2)\n\nCalculate local turbulence intensity using the model presented in Niayifar and  Porte Agel (2015, 2016)\n\nArguments\n\nastar::Float: wake spreading parameter from Bastankhah and Porte-Agel Gaussian wake model\nbstar::Float: wake spreading parameter from Bastankhah and Porte-Agel Gaussian wake model\nk1::Float: slope of k vs TI curve\nk2::Float: vertical offset of k vs TI curve\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.LocalTIModelNoLocalTI","page":"Reference","title":"FLOWFarm.LocalTIModelNoLocalTI","text":"LocalTIModelNoLocalTI()\n\nDon't calculate local turbulence intensity. Ambient TI will be used instead for all points\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.MultiZone","page":"Reference","title":"FLOWFarm.MultiZone","text":"MultiZone(me, ke, MU, aU, bU)\n\nContainer for parameters related to the MultiZone deficit model\n\nArguments\n\nme::Float: parameter controlling general wake expansion. Default value is 0.065\nke::Array{Float}(3): parameters controlling the wake expansion of each zone respectively. Default values are [-0.5 0.22 1.0].\nMU::Array{Float}(3): parameters controlling the wake deficit decay of each zone respectively. Default values are [0.5 1.0 5.5].\naU::Float: parameter impacting the wake deficit decay for a constant wake deflection. Default value is 5.0.\nbU::Float: parameter changing the wake deficit decay under yawed conditions. Default value is 1.66.\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.MultizoneDeflection","page":"Reference","title":"FLOWFarm.MultizoneDeflection","text":"MultizoneDeflection(horizontal_spread_rate)\n\nContainer for parameters related to the Jiminez deflection model\n\nArguments\n\nhorizontal_spread_rate::Float: parameter controlling the wake spreading rate and deficit decay. Default value is 0.1\nad::Float:Helps define the horizontal deflection of the wake at 0 deg yaw\nbd::Float:Helps define the horizontal deflection of the wake due to downwind distance at 0 deg yaw\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.PowerLawWindShear","page":"Reference","title":"FLOWFarm.PowerLawWindShear","text":"PowerLawWindShear(shear_exponent, ground_height)\n\nProvides shear exponent and ground height to define wind shear curve. Ground height may be tuned because the power law does not always hold near the ground.\n\nArguments\n\nshear_exponent::Float: defines trajectory of wind shear\nground_height::Float: height of the ground (typically zero)\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.PowerModelConstantCp","page":"Reference","title":"FLOWFarm.PowerModelConstantCp","text":"PowerModelConstantCp(cp)\n\nModels will assume a constant cp value as provided\n\nArguments\n\ncp::Float: constant power coefficient value\n'pp::TI': exponent for adjusting power for wind turbine yaw\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.PowerModelCpPoints","page":"Reference","title":"FLOWFarm.PowerModelCpPoints","text":"PowerModelCpPoints(vel_points, cp_points)\n\nModels will use adjust cp based on cp curve using linear interpolation of provided points\n\nArguments\n\nvel_points::Array{N,Float}: wind speed values in m/s\ncp_points::Array{N,Float}: power coefficient values corresponding to the provided speeds\n'pp::TF': exponent for adjusting power for wind turbine yaw\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.PowerModelPowerCurveCubic","page":"Reference","title":"FLOWFarm.PowerModelPowerCurveCubic","text":"PowerModelPowerCurveCubic()\n\nPower will be calculated based on turbine specifications assuming a cubic power curve. Note that this method is inherently incorrect and should only be used for theoretical purposes  or after careful validation.\n\nArguments\n\n'pp::TF': exponent for adjusting power for wind turbine yaw\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.PowerModelPowerPoints","page":"Reference","title":"FLOWFarm.PowerModelPowerPoints","text":"PowerModelPowerPoints(vel_points, cp_points)\n\nModels will use adjust wind turbine power based on power curve using linear interpolation of  provided points\n\nArguments\n\nvel_points::Array{N,Float}: wind speed values in m/s\npower_points::Array{N,Float}: power values corresponding to the provided speeds\n'pp::TF': exponent for adjusting power for wind turbine yaw\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.ThrustModelConstantCt","page":"Reference","title":"FLOWFarm.ThrustModelConstantCt","text":"ThrustModelConstantCt(ct::Float)\n\nStores a constant ct value for wake calculations\n\nArguments\n\nct::Float: a constant ct value for computation\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.ThrustModelCtPoints","page":"Reference","title":"FLOWFarm.ThrustModelCtPoints","text":"ThrustModelCtPoints(vel_points, ct_points)\n\nStores the thrust coefficient curve in terms of corresponding velocity and thrust coefficient points. ct and velocity points should be in the same order and ordered from lowest wind speed to highest wind speed.\n\nArguments\n\ninflow_velocity::Float: inflow velocity of the wind turbine\nthrust_model::ThrustModelCtPoints: Struct containing ct and velocity points for ct curve\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.WindFarm","page":"Reference","title":"FLOWFarm.WindFarm","text":"WindFarm(windfarm, windresource, windfarmstates)\n\nStruct defining a wind farm\n\nArguments\n\nturbine_x::Array{Float}(Nturbines): contains windturbine x coordinates in the global reference frame\nturbine_y::Array{Float}(Nturbines): contains windturbine y coordinates in the global reference frame\nturbine_z::Array{Float}(Nturbines): contains windturbine base/z coordinates in the global reference frame\nturbine_definition_ids::Array{Int}(Nturbines): contains integers for each wind turbine specifying its definition\nturbine_definitions::Array{AbstractTurbineDefinition}(Ntypes): contains structs defining each wind turbine definition (design) used in the farm\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.WindFarmModelSet","page":"Reference","title":"FLOWFarm.WindFarmModelSet","text":"WindFarmModelSet(wakedeficitmodel, wake_deflection_model, wake_combination_model, local_ti_model)\n\nContainer for objects defining models to use in wind farm calculations\n\nArguments\n\nwake_defiict_model::AbstractWakeDeficitModel: contains a struct defining the desired wake deficit model\nwake_deflection_model::AbstractWakeDeflectionModel: contains a struct defining the desired wake deflection model\nwake_combination_model::AbstractWakeCombinationModel: contains a struct defining the desired wake combination model\nlocal_ti_model::AbstractTurbulenceIntensityModel: contains a struct defining the desired turbulence intensity model\n\n\n\n\n\n","category":"type"},{"location":"Reference/#FLOWFarm.DiscreteCircum","page":"Reference","title":"FLOWFarm.DiscreteCircum","text":"PointsOnCircum(center_x, center_y, r, n = 100)\n\nGiven a circle center, radius, and number of discrete points, returns an array of discrete points along the circle's circumference\n\nArguments\n\ncenter_x::Float64 : cartesian x-coordinate for the center of the circle\ncenter_y::Float64 : cartesian y-coordinate for the center of the circle\nr::Float64 : distance from circle's center to the circumference points\nn::Float64 : defaults to 100, is the number of discrete evenly-spaced points       that will be returned along the circle's circumference\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.GaussianTI-NTuple{8, Any}","page":"Reference","title":"FLOWFarm.GaussianTI","text":"GaussianTI(loc,turbine_x, turbine_y, rotor_diameter, hub_height, turbine_ct, \n    sorted_turbine_index, ambient_ti; div_sigma=2.5, div_ti=1.2)\n\nCalculate local turbulence intensity based on \"On wake modeling, wind-farm gradients and AEP      predictions at the Anholt wind farm\" by Pena Diaz, Alfredo; Hansen, Kurt Schaldemose;      Ott, SÃ¸ren; van der Laan, Paul ??\n\nArguments\n\nloc::Array{Float,3}: [x,y,z] location of point of interest in wind direction ref. frame\nturbine_x::Array{Float,nTurbines}: turbine wind direction locations in the wind direction    reference frame\nturbine_y::Array{Float,nTurbines}: turbine cross wind locations in the wind direction    reference frame\nrotor_diameter::Array{Float,nTurbines}: rotor diameters of all turbines\nhub_height::Array{Float,nTurbines}: hub heights of all turbines relative to the ground\nturbine_ct::Array{Float,nTurbines}: thrust coefficient of each turbine for the given state\nsorted_turbine_index::Array{Float,nTurbines}: turbine north-south locations in the    global reference frame\nambient_ti::Float: ambient turbulence intensity\ndiv_sigma::Float: ?\ndiv_ti::Float: ?\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.VR_boundary-NTuple{5, Any}","page":"Reference","title":"FLOWFarm.VR_boundary","text":"VR_boundary(bndry_x_clsd, bndry_y_clsd, start_dist, turb_spacing, num_turbs, bndry_seg_length)\n\nUses the Boundary portion of Boundary-Grid variable reduction method place turbines along a closed wind farm boundary and perturb their location with one (1) variable <startdist>.  NOTE: Use of this function assumes prior use of VRbounary_startup(), which ensures the number of turbines placed on the boundary doesn't violate any minimum spacing rules eiter along the boundary or around corners.\n\nArguments\n\nbndry_x::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndry_y::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\nstart_dist::Float64: the distance (positive or negative) along the boundary       from the first boundary point where the turbines will begin to be placed\nturb_spacing::Float64: the fixed distance along the boundary's edge between       adjacent turbines\n'numturbs::Float64`: the number of turbines to be placed around the boundary.       Note that this function assumes VRbounary_startup() has already been       run so that the user won't attempt to place too many turbines.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.VR_boundary_startup-NTuple{5, Any}","page":"Reference","title":"FLOWFarm.VR_boundary_startup","text":"VR_bounary_startup(bndry_x_clsd, bndry_y_clsd, start_dist, turb_min_spacing, num_turbs)\n\nDetermines if the requested number of turbines can be placed along the closed boundary with spacing and corner constraints. If the requested <num_turbs> is too many, places as many turbines as possible along the boundary, and returns the number of turbines not placed. NOTE: A shortcoming is that the smallest-angled corner limits the spacing of all turbines. in the worst case, a very thin boundary area would prevent any more than one turbine being placed on the boundary, though more would be optimal. Future work would check to make sure this corner (and the length of its adjacent sides) don't actually require limiting the minimum distance between turbines.\n\nArguments\n\nbndry_x::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndry_y::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\nstart_dist::Float64: the distance (positive or negative) along the boundary       from the first boundary point where the turbines will begin to be placed\nturb_spacing::Float64: the fixed distance along the boundary's edge between       adjacent turbines\n'numturbs::Float64`: the number of turbines to be placed around the boundary.       Note that this function assumes VRbounary_startup() has already been       run so that the user won't attempt to place too many turbines.\n'bndryseglength::Array{Int}`: an array of the lengths between adjacent       boundary verticies, corresponding to how they appear in bndry_x and _y\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm._ct_to_axial_ind_func-Tuple{Any}","page":"Reference","title":"FLOWFarm._ct_to_axial_ind_func","text":"_ct_to_axial_ind_func(ct)\n\nCalculate axial induction from the thrust coefficient\n\nArguments\n\nct::Float: thrust coefficient\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm._gauss_yaw_potential_core-NTuple{6, Any}","page":"Reference","title":"FLOWFarm._gauss_yaw_potential_core","text":"_gauss_yaw_potential_core(dt, yaw, ct, as, ti, bs)\n\nHelper function for wakedeficitmodel when using the GaussYaw model. Computes the length of the near wake potential core.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm._gauss_yaw_spread-NTuple{5, Any}","page":"Reference","title":"FLOWFarm._gauss_yaw_spread","text":"_gauss_yaw_spread(dt, k, dx, x0, yaw)\n\nHelper function for wakedeficitmodel when using the GaussYaw model. Computes the standard deviation of the wake.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm._gauss_yaw_spread_interpolated-NTuple{5, Any}","page":"Reference","title":"FLOWFarm._gauss_yaw_spread_interpolated","text":"_gauss_yaw_spread_interpolated(dt, k, dx, x0, yaw)\n\nHelper function for wakedeficitmodel when using the GaussYaw model. Computes the standard deviation of the wake. with an interpolation on the near wake. \n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm._niayifar_added_ti_function-NTuple{12, Any}","page":"Reference","title":"FLOWFarm._niayifar_added_ti_function","text":"_niayifar_added_ti_function(x, d_dst, d_ust, h_ust, h_dst, ct_ust, kstar_ust, delta_y, \n    ti_amb, ti_ust, ti_dst, ti_area_ratio_in; s=700.0)\n\nMain code for calculating the local turbulence intensity at a turbine using the method of     Niayifar and Porte Agel (2015, 2016).\n\nArguments\n\nx::Float: downstream distance from turbine to point of interest\nd_dst::Float: downstream turbine rotor diameter\nd_ust::Float: upstream turbine rotor diameter\nh_ust::Float: upstream turbine hub height\nh_dst::Float: downstream turbine hub height\nct_ust::Float: upstream turbine thrust coefficient\nkstar_ust::Float: upstream turbine wake expansion rate\ndelta_y::Float: cross wind separation from turbine to point of interest\nti_amb::Float: ambient turbulence intensity\nti_ust::Float: upstream turbine local turbulence intensity\nti_dst::Float: downstream turbine local turbulence intensity\nti_area_ratio_in::Float: current value of TI-area ratio for use in calculatin local TI\ns::Float: smooth max smootheness parameter\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm._remove_out_of_bounds_points-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm._remove_out_of_bounds_points","text":"_remove_perimeter_points!(n; alpha=0.0)\n\nInternal function. Removes points outside or outside and on the border of the rotor-swept      area \n\nArguments\n\ny::AbstractArray: horizontal point locations\nz::AbstractArray: vertical point locations \nuse_perimeter_points::Bool: flag that determines whether or not to include points on the    boundary of the rotor-swept area\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.adjust_for_wind_shear-Tuple{Any, Any, Any, Any, FLOWFarm.PowerLawWindShear}","page":"Reference","title":"FLOWFarm.adjust_for_wind_shear","text":"adjust_for_wind_shear(locz, reference_velocity, reference_height, ground_height, model::PowerLawWindShear)\n\nUses provided velocity at a given height to estimate the velocity at a different height due to wind shear. Ground height may be tuned because the power law does not always hold near the ground.\n\nArguments\n\nlocz::Float: height of desired velocity\nreference_velocity::Float: known velocity at reference_height\nreference_height::Float: height of known velocity \nground_height::Float: height of the ground (typically zero)\nmodel::AbstractWindShearModel: wind shear model to use for calculations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calcMinorAngle","page":"Reference","title":"FLOWFarm.calcMinorAngle","text":"calcMinorAngle(bndry_x, bndry_y, bndry_z=[0,0,0])\n\nGiven three points in space, calculates the magnitude of the non-reflex angle formed at the center point. Created to be used in VRbounarystartup()\n\nArguments\n\nbndry_x::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndry_y::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\nbndry_z::Array{Float,1} : 1-D array of z-coordinates for the vertices       around a singlar closed boundary. Default to [0,0,0] for X-Y plane\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.calcSmallestAngle-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.calcSmallestAngle","text":"calcSmallestAngle(bndry_x_clsd, bndry_y_clsd)\n\nGiven a 1-D closed array of boundary verticies (with first point repeated at the end) it determines the smallest non-reflex angle created by any three consecutive verticies along the boundary. Created to be used in VRbounarystartup()\n\nArguments\n\nbndry_x::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndry_y::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calc_moment_stress","page":"Reference","title":"FLOWFarm.calc_moment_stress","text":"calc_moment_stress(mx,my,dx,dy,Rcyl=1.771,tcyl=0.06)\n\nCalculates stresses from bending moments on a hollow cylinder\n\nArguments\n\nmx::Float: x moment\nmy::Float: y moment\ndx::Float: x distance to the location of interest\ndy::Float: y distance to the location of interest\n\nKeyword Arguments\n\nRcyl::Float: radius of the cylinder\ntcyl::Float: thickenss of the cylinder\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.calculate_aep-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}","page":"Reference","title":"FLOWFarm.calculate_aep","text":"calculate_aep(turbine_x, turbine_y, turbine_z, rotor_diameter,\nhub_height, turbine_yaw, ct_model, generator_efficiency, cut_in_speed,\ncut_out_speed, rated_speed, rated_power, wind_resource, power_models::Array{AbstractPowerModel}, model_set::AbstractModelSet;\nrotor_sample_points_y=[0.0], rotor_sample_points_z=[0.0], hours_per_year=365.25*24.0)\n\nCalculate wind farm AEP\n\nArguments\n\nturbine_x::Array{Float,nTurbines}: turbine east-west locations in the global    reference frame\nturbine_y::Array{Float,nTurbines}: turbine north-south locations in the global    reference frame\nturbine_z::Array{Float,nTurbines}: turbine base height in the global reference frame\nrotor_diameter::Array{Float,nTurbines}\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in    radians\nct_model::AbstractThrustCoefficientModel: defines how the thrust coefficient changes    with state etc\ngenerator_efficiency::Array{Float,nTurbines}\ncut_in_speed::Array{Float,nTurbines} \ncut_out_speed::Array{Float,nTurbines}\nrated_speed::Array{Float,nTurbines}\nrated_power::Array{Float,nTurbines}\nwind_resource::DiscretizedWindResource: wind resource discreption (directions, speeds,    frequencies, etc)\npower_model::Array{): elements of array should be sub types of AbstractPowerModel\nmodel_set::AbstractModelSet: defines wake-realated models to be used in analysis\nrotor_sample_points_y::Array{TF,N}: horizontal wind location of points to sample across    the rotor swept area when calculating the effective wind speed for the wind turbine.    Points are centered at the hub (0,0) and scaled by the radius (1=tip of blades) \nrotor_sample_points_z::Array{TF,N}: vertical wind location of points to sample across the    rotor swept area when calculating the effective wind speed for the wind turbine. Points   are centered at the hub (0,0) and scaled by the radius (1=tip of blades)\nhours_per_year::Float: hours per year (averaged for leap year by default)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_ct-Tuple{Any, FLOWFarm.ThrustModelConstantCt}","page":"Reference","title":"FLOWFarm.calculate_ct","text":"calculate_ct(model::ThrustModelConstantCt)\n\nCalculate the thrust coefficient for a wind turbine based on a pre-determined constant ct\n\nArguments\n\ninflow_velocity::Float: inflow velocity of the wind turbine (unused for const. ct)\nthrust_model::ThrustModelConstantCt: struct containing a constant ct value for computation\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_ct-Tuple{Any, FLOWFarm.ThrustModelCtPoints}","page":"Reference","title":"FLOWFarm.calculate_ct","text":"calculate_ct(inflow_velocity, thrust_model::ThrustModelCtPoints)\n\nCalculate the thrust coefficient for a wind turbine based on a pre-determined ct curve\n    with linear interpolation.\n\nArguments\n\ninflow_velocity::Float: inflow velocity of the wind turbine\nthrust_model::ThrustModelCtPoints: Struct containing ct and velocity points for ct curve\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_flow_field-Tuple{Any, Any, Any, FLOWFarm.AbstractModelSet, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}","page":"Reference","title":"FLOWFarm.calculate_flow_field","text":"calculateflowfield(xrange, yrange, zrange, modelset::AbstractModelSet, turbinex,      turbiney, turbinez, turbineyaw, turbinect, turbineai, rotordiameter, hubheight,      turbinelocalti, sortedturbineindex, wtvelocities, windresource; windfarmstate_id=1)\n\nGenerates a flow field for a given state and cross section\n\nArguments\n\nxrange::Range: range defining east-west locations to sample in global reference frame\nyrange::Range: range defining north-west locations to sample in global reference frame\nzrange::Range: range defining vertical locations to sample in global reference frame\nmodel_set::AbstractModelSet: defines wake-realated models to be used in analysis\nturbine_x::Array{TF,nTurbines}: turbine east-west locations in the global    reference frame\nturbine_y::Array{TF,nTurbines}: turbine north-south locations in the global    reference frame\nturbine_z::Array{TF,nTurbines}: turbine base height in the global reference frame\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in    radians\nturbine_ct::Array{TF,nTurbines}: thrust coefficient of each turbine for the given state\nturbine_ai::Array{TF,nTurbines}: turbine axial induction for the given state\nrotor_diameter::Array{TF,nTurbines}: turbine rotor diameters\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_local_ti::Array{TF,nTurbines}: turbine local turbulence intensity for    the given state\nsorted_turbine_index::Array{TF,nTurbines}: turbine north-south locations in the    global reference frame\nwtvelocities::Array{TF,nTurbines}: effective inflow wind speed for given state\nwind_resource::DiscretizedWindResource: wind resource discreption (directions, speeds,    frequencies, etc)\nwind_farm_state_id::Int: index to correct state to use from wind resource provided.   Defaults to 1\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_local_ti-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.LocalTIModelMaxTI}","page":"Reference","title":"FLOWFarm.calculate_local_ti","text":"calculate_local_ti(turbine_x, turbine_y, ambient_ti, rotor_diameter, hub_height, turbine_yaw, turbine_local_ti, sorted_turbine_index,\nturbine_inflow_velcities, turbine_ct, ti_model::LocalTIModelMaxTI; turbine_id=1, tol=1E-6)\n\nReturns local turbulence intensity calculated using Niayifar and Porte Agel 2015, 2016 using smooth max on area TI ratio\n\nArguments\n\nturbine_x::Array{Float,nTurbines}: turbine wind direction locations in the wind direction    reference frame\nturbine_y::Array{Float,nTurbines}: turbine cross wind locations in the wind direction    reference frame\nambient_ti::Float: ambient turbulence intensity\nrotor_diameter::Array{Float,nTurbines}: rotor diameters of all turbines\nhub_height::Array{Float,nTurbines}: hub heights of all turbines relative to the ground\nturbine_yaw::Array{Float,nTurbines}: yaw of all turbines for the current wind state in radians\nturbine_local_ti::Array{Float,nTurbines}: local turbulence intensity of all turbines for the current wind state`\nsorted_turbine_index::Array{Float,nTurbines}: turbine north-south locations in the    global reference frame\nturbine_inflow_velcities::Array{Float,nTurbines}: effective inflow wind speed at each turbine for given state\nturbine_ct::Array{Float,nTurbines}: thrust coefficient of each turbine for the given state\nti_model::LocalTIModelMaxTI: contains a struct defining the desired turbulence intensity model, no local TI in this case\nturbine_id::Int: index of wind turbine of interest. Provide 1 as default.\ntol::Float: How far upstream a turbine should be before being included in TI calculations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_local_ti-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.LocalTIModelNoLocalTI}","page":"Reference","title":"FLOWFarm.calculate_local_ti","text":"calculate_local_ti(turbine_x, turbine_y, ambient_ti, rotor_diameter, hub_height, turbine_yaw, turbine_local_ti, sorted_turbine_index,\nturbine_inflow_velcities, turbine_ct, ti_model::LocalTIModelNoLocalTI; turbine_id=1, tol=1E-6)\n\nReturns ambient turbulence intesity value whenever local turbulence intensity is requestesd\n\nArguments\n\nturbine_x::Array{Float,nTurbines}: turbine wind direction locations in the wind direction    reference frame\nturbine_y::Array{Float,nTurbines}: turbine cross wind locations in the wind direction    reference frame\nambient_ti::Float: ambient turbulence intensity\nrotor_diameter::Array{Float,nTurbines}: rotor diameters of all turbines\nhub_height::Array{Float,nTurbines}: hub heights of all turbines relative to the ground\nturbine_yaw::Array{Float,nTurbines}: yaw of all turbines for the current wind state in radians\nturbine_local_ti::Array{Float,nTurbines}: local turbulence intensity of all turbines for the current wind state`\nsorted_turbine_index::Array{Float,nTurbines}: turbine north-south locations in the    global reference frame\nturbine_inflow_velcities::Array{Float,nTurbines}: effective inflow wind speed at each turbine for given state\nturbine_ct::Array{Float,nTurbines}: thrust coefficient of each turbine for the given state\nti_model::LocalTIModelNoLocalTI: contains a struct defining the desired turbulence intensity model, no local TI in this case\nturbine_id::Int: index of wind turbine of interest. Provide 1 as default.\ntol::Float: How far upstream a turbine should be before being included in TI calculations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.PowerModelConstantCp}","page":"Reference","title":"FLOWFarm.calculate_power","text":"calculate_power(generator_efficiency, air_density, rotor_area, wt_velocity, power_model)\n\nCalculate the power for a wind turbine based on standard theory for region 2 using a constant cp\n\nArguments\n\ngenerator_efficiency::Float: Efficiency of the turbine generator\nair_density::Float: Air density\nrotor_area::Float: Rotor-swept area of the wind turbine\nwt_velocity::Float: Inflow velocity to the wind turbine\ncut_in_speed::Float: cut in speed of the wind turbine\nrated_speed::Float: rated speed of the wind turbine\ncut_out_speed::Float: cut out speed of the wind turbine\nrated_power::Float: rated power of the wind turbine\npower_model::PowerModelConstantCp: Struct containing the cp value to be used in region 2\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.PowerModelCpPoints}","page":"Reference","title":"FLOWFarm.calculate_power","text":"calculate_power(generator_efficiency, air_density, rotor_area, wt_velocity, cut_in_speed, rated_speed, cut_out_speed, rated_power, power_model)\n\nCalculate the power for a wind turbine based on a cp curve with linear interpolation\n\nArguments\n\ngenerator_efficiency::Float: Efficiency of the turbine generator\nair_density::Float: Air density\nrotor_area::Float: Rotor-swept area of the wind turbine\nwt_velocity::Float: Inflow velocity to the wind turbine\ncut_in_speed::Float: cut in speed of the wind turbine\nrated_speed::Float: rated speed of the wind turbine\ncut_out_speed::Float: cut out speed of the wind turbine\nrated_power::Float: rated power of the wind turbine\npower_model::PowerModelCpPoints: Struct containing the velocity and cp values defining the cp curve\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.PowerModelPowerCurveCubic}","page":"Reference","title":"FLOWFarm.calculate_power","text":"calculate_power(generator_efficiency, air_density, rotor_area, wt_velocity, cut_in_speed, rated_speed, cut_out_speed, rated_power, power_model)\n\nCalculates wind turbine power using a cubic estimation based on turbine specifications     as defined in https://github.com/byuflowlab/iea37-wflo-casestudies/blob/master/cs3-4/iea37-cs3-announcement.pdf\n\nArguments\n\ngenerator_efficiency::Float: Efficiency of the turbine generator\nair_density::Float: Air density\nrotor_area::Float: Rotor-swept area of the wind turbine\nwt_velocity::Float: Inflow velocity to the wind turbine\ncut_in_speed::Float: cut in speed of the wind turbine\nrated_speed::Float: rated speed of the wind turbine\ncut_out_speed::Float: cut out speed of the wind turbine\nrated_power::Float: rated power of the wind turbine\npower_model::PowerModelPowerCurveCubic: Empty struct\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.PowerModelPowerPoints}","page":"Reference","title":"FLOWFarm.calculate_power","text":"calculate_power(generator_efficiency, air_density, rotor_area, wt_velocity, cut_in_speed, rated_speed, cut_out_speed, rated_power, power_model)\n\nCalculate the power for a wind turbine based on a pre-determined power curve with linear     interpolation\n\nArguments\n\ngenerator_efficiency::Float: Efficiency of the turbine generator\nair_density::Float: Air density\nrotor_area::Float: Rotor-swept area of the wind turbine\nwt_velocity::Float: Inflow velocity to the wind turbine\ncut_in_speed::Float: cut in speed of the wind turbine\nrated_speed::Float: rated speed of the wind turbine\ncut_out_speed::Float: cut out speed of the wind turbine\nrated_power::Float: rated power of the wind turbine\npower_model::PowerModelPowerPoints: Struct containing the velocity and power values   defining the power curve\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_power_from_cp-NTuple{6, Any}","page":"Reference","title":"FLOWFarm.calculate_power_from_cp","text":"calculate_power_from_cp(generator_efficiency, air_density, rotor_area, cp, wt_velocity)\n\nCalculate the power for a wind turbine based on standard theory for region 2\n\nArguments\n\ngenerator_efficiency::Float: Efficiency of the turbine generator\nair_density::Float: Air density\nrotor_area::Float: Rotor-swept area of the wind turbine\ncp::Float: Power coefficient of the wind turbine\nwt_velocity::Float: Inflow velocity to the wind turbine\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_state_aeps-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}","page":"Reference","title":"FLOWFarm.calculate_state_aeps","text":"calculate_state_aeps(turbine_x, turbine_y, turbine_z, rotor_diameter,\nhub_height, turbine_yaw, ct_model, generator_efficiency, cut_in_speed,\ncut_out_speed, rated_speed, rated_power, wind_resource, power_models::Array{AbstractPowerModel}, model_set::AbstractModelSet;\nrotor_sample_points_y=[0.0], rotor_sample_points_z=[0.0])\n\nCalculate AEP for each requested state respectively\n\nArguments\n\nturbine_x::Array{Float,nTurbines}: turbine east-west locations in the global    reference frame\nturbine_y::Array{Float,nTurbines}: turbine north-south locations in the global    reference frame\nturbine_z::Array{Float,nTurbines}: turbine base height in the global reference frame\nrotor_diameter::Array{Float,nTurbines}\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in    radians\nct_model::AbstractThrustCoefficientModel: defines how the thrust coefficient changes    with state etc\ngenerator_efficiency::Array{Float,nTurbines}\ncut_in_speed::Array{Float,nTurbines} \ncut_out_speed::Array{Float,nTurbines}\nrated_speed::Array{Float,nTurbines}\nrated_power::Array{Float,nTurbines}\nwind_resource::DiscretizedWindResource: wind resource discreption (directions, speeds,    frequencies, etc)\npower_model::Array{nTurbines}: elemenst of array should be sub-types of AbstractPowerModel\nmodel_set::AbstractModelSet: defines wake-realated models to be used in analysis\nrotorsamplepoints_y::Array{TF,N}`: horizontal wind location of points to sample across    the rotor swept area when calculating the effective wind speed for the wind turbine.    Points are centered at the hub (0,0) and scaled by the radius (1=tip of blades) \nrotorsamplepoints_z::Array{TF,N}`: vertical wind location of points to sample across the    rotor swept area when calculating the effective wind speed for the wind turbine. Points   are centered at the hub (0,0) and scaled by the radius (1=tip of blades)\nhours_per_year::Float: hours per year (averaged for leap year by default)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_state_turbine_powers-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}","page":"Reference","title":"FLOWFarm.calculate_state_turbine_powers","text":"calculate_state_turbine_powers(turbine_x, turbine_y, turbine_z, rotor_diameter,\nhub_height, turbine_yaw, ct_model, generator_efficiency, cut_in_speed,\ncut_out_speed, rated_speed, rated_power, wind_resource, power_models, model_set::AbstractModelSet;\nrotor_sample_points_y=[0.0], rotor_sample_points_z=[0.0])\n\nCalculate power for each turbine for all states respectively\n\nArguments\n\nturbine_x::Array{Float,nTurbines}: turbine east-west locations in the global    reference frame\nturbine_y::Array{Float,nTurbines}: turbine north-south locations in the global    reference frame\nturbine_z::Array{Float,nTurbines}: turbine base height in the global reference frame\nrotor_diameter::Array{Float,nTurbines}\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in    radians\nct_model::AbstractThrustCoefficientModel: defines how the thrust coefficient changes    with state etc\ngenerator_efficiency::Array{Float,nTurbines}\ncut_in_speed::Array{Float,nTurbines} \ncut_out_speed::Array{Float,nTurbines}\nrated_speed::Array{Float,nTurbines}\nrated_power::Array{Float,nTurbines}\nwind_resource::DiscretizedWindResource: wind resource discreption (directions, speeds,    frequencies, etc)\npower_models::Array{nTurbines}: elemenst of array should be sub-types of AbstractPowerModel\nmodel_set::AbstractModelSet: defines wake-realated models to be used in analysis\nrotorsamplepoints_y::Array{TF,N}`: horizontal wind location of points to sample across    the rotor swept area when calculating the effective wind speed for the wind turbine.    Points are centered at the hub (0,0) and scaled by the radius (1=tip of blades) \nrotorsamplepoints_z::Array{TF,N}`: vertical wind location of points to sample across the    rotor swept area when calculating the effective wind speed for the wind turbine. Points   are centered at the hub (0,0) and scaled by the radius (1=tip of blades)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.calculate_turbine_power-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractPowerModel, Any}","page":"Reference","title":"FLOWFarm.calculate_turbine_power","text":"calculate_turbine_power(generator_efficiency, cut_in_speed, cut_out_speed, rated_speed, \nrated_power, rotor_diameter, wt_velocity, power_model::AbstractPowerModel, air_density)\n\nCalculate the power for all wind turbines. Dispaches to desired power model.\n\nArguments\n\ngenerator_efficiency::Array{Float,nTurbines}\ncut_in_speed::Array{Float,nTurbines} \ncut_out_speed::Array{Float,nTurbines}\nrated_speed::Array{Float,nTurbines}\nrated_power::Array{Float,nTurbines}\nrotor_diameter::Array{Float,nTurbines}\nwt_velocity::Array{Float,nTurbines}: turbine effective wind speeds for current state only\n`power_model::AbstractPowerModel)\nair_density::Float\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.circle_boundary-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.circle_boundary","text":"circle_boundary(center,radius,turbine_x,turbine_y)\n\ncalculate the distance from each turbine to a circular boundary. Negative means the turbine is inside the boundary\n\nArguments\n\ncenter::Float: circular boundary center [x,y]\nradius::Float: circulat boundary radius\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.closeBndryList-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.closeBndryList","text":"closeBndryList(bndryPts_x, bndryPts_y)\n\nAppends the 1st element to the end of the coordinate arrays if it is not already repeated. Note, this will only work on 1-D arrays. For an array of 1-D arrays, use closeBndryLists(bndryPts_x, bndryPts_y) (note the plural, not singular 'Lists' in the function title)\n\nArguments\n\nbndryPts_x::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndryPts_y::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.closeBndryLists-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.closeBndryLists","text":"closeBndryLists(bndryPts_x, bndryPts_y)\n\nAppends the 1st element to the end of each array for a closed boundary. Note, this will not function properly if there is only one region. For only one region, use closeBndryList(bndryPts_x, bndryPts_y) (note the singular, not plural 'List' in the function title)\n\nArguments\n\nbndryPts_x::Array{Float,1} : N-D array of x-coordinates for the vertices       around N-many closed boundaries\nbndryPts_y::Array{Float,1} : N-D array of y-coordinates for the vertices       around N-many closed boundaries\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.convex_boundary-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.convex_boundary","text":"convex_boundary(boundary_vertices,boundary_normals,turbine_x,turbine_y)\n\ncalculate the distance from each turbine to a possibly non-circular, but convex boundary. Negative means the turbine is inside the boundary\n\nArguments\n\nboundary_vertices::Array{Float,2}: vertices of the convex hull CCW in order s.t.       boundaryVertices[i] -> first point of face for unit_normals[i]\nboundary_normals::Array{Float,2}: unit normal vector for each boundary face       CCW where boundaryVertices[i] is the first point of the corresponding face\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.coordDist-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.coordDist","text":"coordDist(x1, y1, x2, y2)\n\nGiven a two points (x1, y1) and (x2, y2), returns the euclidean distance between them\n\nArguments\n\nx1::Float64 : x-coord of the first point\ny1::Float64 : y-coord of the first point\nx2::Float64 : x-coord of the second point\ny2::Float64 : y-coord of the second point\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.distributed_velocity_op","page":"Reference","title":"FLOWFarm.distributed_velocity_op","text":"distributed_velocity_op(V, Omega, r, precone, yaw, tilt, azimuth, rho, mu=1.81206e-05, asound=1.0)\n\nReturn the operating points along the blade considering varied inflow along the blade.\n\nArguments\n\nV::Array{Float}: velocity inflow at each r\nOmega::Float: rotor rotational speed\nr::Array{Float}: radial locations of interest\nprecone::Float: rotor precone angle\nyaw::Float: rotor yaw angle\ntilt::Float: rotor tilt angle\nazimuth::Float: blade azimuth angle\nrho::Float: air density\n\nKeyword Arguments\n\nmu::Float: air viscocity (can usually use the default)\nasound::Float: speed of sound (can usually use the default)\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.find_upstream_turbines-Tuple{Any, Any, AbstractArray, Any}","page":"Reference","title":"FLOWFarm.find_upstream_turbines","text":"find_upstream_turbines(turbinex, turbiney, winddirection, diameter; inverse=false)\n\nA convenience function to quickly find either which turbines are waked, or those that are  not. \n\nArguments\n\nturbinex::Array{T,1}: x locations of turbines in global reference frame \nturbiney::Array{T,1}: y locations of turbines in global reference frame\nwinddirection::Real or winddirection::AbstractArray: wind direction in radians in meteorological coordinates (0 rad. = from North)\ndiameter::Array{T,1}: diameters of all wind turbines\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.find_xyz_simple-NTuple{6, Any}","page":"Reference","title":"FLOWFarm.find_xyz_simple","text":"find_xyz_simple(x_hub,y_hub,z_hub,r,yaw,azimuth)\n\nFind the xyz locations of points along a blade given it's location and azimuth angle. Currently doesn't consider precone or tilt.\n\nArguments\n\nx_hub::Float: x location of hub\ny_hub::Float: y location of hub\nz_hub::Float: z location of hub (hub height if no topology)\nr::Array{Float}: radial locations of interest\nprecone::Float: rotor precone angle\nyaw::Float: rotor yaw angle\nazimuth::Float: blade azimuth angle\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.getNextFileName","page":"Reference","title":"FLOWFarm.getNextFileName","text":"getNextFileName(directory, file_name, file_type)\n\nChecks if a file of the given directory and name exists. If not, increments to the next index so as not to overwrite previously written files. If it reaches the max number of overwrites, it will default to <directory/filename.filetype> To default to this, set <max_check=0> in function call.\n\nArguments\n\ndirectory::String: path/to/write/file/at/\nfile_name::String: Whatever the name of the file desired\nfile_type::String: ex \"yaml\", \"txt\", \"csv\", etc...\nmax_check::Int: the maximum number of files to check\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.getPerimeterLength-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.getPerimeterLength","text":"getPerimeterLength(bndry_x_clsd, bndry_y_clsd)\n\nGiven a 1-D closed array of boundary verticies (with first point repeated at the end) returns the length along the perimeter. Created to be used in VRbounarystartup()\n\nArguments\n\nbndry_x::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndry_y::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.getUpDwnYvals-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.getUpDwnYvals","text":"getUpDwnYvals(turbine_x, bndry_x_clsd, bndry_y_clsd, bndry_corner_indcies)\n\nSupplements FLOWFarm's splinedboundary() function by calculating (for a given x location) the maximum and minimum y-value permitted to remain \"inside\" the boundary. If turbinex is located left of the boundary's leftmost vertex or right of the boundary's rightmost vertex, it return's that corresponding vertex's y-value as the max and min, as default. Returns two values, the minimum and maximum interior y-values withing a boundary for the given turbine_x value. Note that all boundary coordinates must be in the first quadrant of the Cartesian coordinate system (+x and +y values only)\n\nArguments\n\nturbine_x::Array{Float}: x-value of the turbine being examined\nbndry_x_clsd::Array{Float}: x locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.\nbndry_y_clsd::Array{Float}: y locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.\nbndry_corner_indcies::Array{Float}: An array of 3 or 4 indicies in the       bndryx/yclsd arrays that correspond to the three four \"corners\" used       between splined \"sides\"\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_boundary_yaml-Tuple{Any}","page":"Reference","title":"FLOWFarm.get_boundary_yaml","text":"get_boundary_yaml(filename)\n\nReturns the boundaries of a wind farm as defined in a yaml file in the format used in FLOWFarm. Returns N by 2 array for single region farm and an array of  N by 2 arrays for multiple regions. Returned regions are sorted alphabetically by the keys provided in the yaml file.\n\nArguments\n\nfile_name::String: relative/path/to/file\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_moments-NTuple{7, Any}","page":"Reference","title":"FLOWFarm.get_moments","text":"get_moments(out,Rhub,Rtip,r,az,precone,tilt)\n\nTrapezoidal integration to find the blade root bending moment using the loads distribution\n\nArguments\n\n`out::CCBlade dict: output from running CCBlade solve\nRhub::Float: radius of the rotor hub\nRtip::Float: radius of the blade tip\nr::Array{Float}: radial locations of interest\naz::Float: blade azimuth angle\nprecone::Float: rotor precone angle\ntilt::Float: rotor tilt angle\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_peaks-Tuple{Any}","page":"Reference","title":"FLOWFarm.get_peaks","text":"get_peaks(array)\n\nget the turning point values of a signal\n\nArguments\n\narray::Array{Float}: the signal to find the turning points, or peaks\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_peaks_indices-Tuple{Any}","page":"Reference","title":"FLOWFarm.get_peaks_indices","text":"get_peaks_indices(array)\n\nreturn the indices of the signal peaks\n\nArguments\n\narray::Array{Float}: the signal to find the turning points, or peaks\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_turb_atrbt_YAML-Tuple{Any}","page":"Reference","title":"FLOWFarm.get_turb_atrbt_YAML","text":"get_turb_atrbt_YAML(file_name)\n\nread in turbine attributes from .yaml\n\nArguments\n\nfile_name::String: path/to/attribute/file.yaml\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_turb_loc_YAML-Tuple{Any}","page":"Reference","title":"FLOWFarm.get_turb_loc_YAML","text":"get_turb_loc_YAML(file_name)\n\nread in turbine locations and related problem file names from .yaml\n\nArguments\n\nfile_name::String: path/and/name/of/location/file.yaml\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.get_wind_rose_YAML-Tuple{Any}","page":"Reference","title":"FLOWFarm.get_wind_rose_YAML","text":"get_wind_rose_YAML(file_name)\n\nread in wind resource information from .yaml\n\nArguments\n\nfile_name::String: path/to/wind/resource/file.yaml\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.grid_points-Tuple{Any}","page":"Reference","title":"FLOWFarm.grid_points","text":"grid_points(n)\n\nGenerates points in a grid. If n is not a perfect square, then the nearest square root will  be used for the side length of the grid.\n\nArguments\n\nn::Float: number of points to generate\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.hermite_spline-NTuple{7, Any}","page":"Reference","title":"FLOWFarm.hermite_spline","text":"hermite_spline(x, x0, x1, y0, dy0, y1, dy1)\n\nProduces the y and (optionally) dy values for a hermite cubic spline interpolating between two end points with known slopes\n\nArguments\n\nx::Float: x position of output y\nx0::Float: x position of upwind endpoint of spline\nx1::Float: x position of downwind endpoint of spline\ny0::Float: y position of upwind endpoint of spline\ndy0::Float: slope at upwind endpoint of spline\ny1::Float: y position of downwind endpoint of spline\ndy1::Float: slope at downwind endpoint of spline\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.iea37cs4BndryVRIntPM-NTuple{6, Any}","page":"Reference","title":"FLOWFarm.iea37cs4BndryVRIntPM","text":"iea37cs4BndryVRIntPM(bndry_x_clsd, bndry_y_clsd, bndry_corner_indcies, turbine_x, turbine_y, turb_diam, turb_min_space, num_turbs_to_place)\n\nUses the Variable reduction method for placing boundary turbines, and the Partition Method (from splined_boundary()) for random interior points, maintaining proper spacing from all previously placed turbines.\n\nArguments\n\nbndry_x_clsd::Array{Float,1} : 1-D array of x-coordinates for the vertices       around a singlar closed boundary\nbndry_y_clsd::Array{Float,1} : 1-D array of y-coordinates for the vertices       around a singlar closed boundary\nbndry_corner_indcies::Float64: The indicies within <bndryxclsd> and       <bndryyclsd> which denote the \"corners\" adjacent turbines\n'turbminspace::Float64`: For proximity knowledge, the minimum spacing       required between any two turbines\n'numbndryturbs::Float64`: The number of turbines desired to be placed along       the boundary. If too many are selected (due to spacing condtraints), the       remaining will be placed in the interior\n'numtotturbs::Float64`: The number of total turbines to be placed both on       the boundary and in the interior\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.latlong_to_xy-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm.latlong_to_xy","text":"latlong_to_xy(latitude, longitude, utm_zone; isnorth=true, units=\"m\")\n\nConverts arrays of points from latitude and longitude to x and y in meters in a local coordinate frame based on the point with the lowest magnitude latitude,\n\nArguments\n\nlatitude::Array{Float,N}\nlongitude::Array{Float,N}\nisnorth::Float: specifies if the point is in the northern hemisphere (defaul: true)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.multiple_components_op","page":"Reference","title":"FLOWFarm.multiple_components_op","text":"multiple_components_op(U, V, W, Omega, r, precone, yaw, tilt, azimuth, rho, mu=1.81206e-05, asound=1.0)\n\nReturn the operating points along the blade considering all the inflow velocity components.\n\nArguments\n\nU::Array{Float}: u velocity component of the inflow at each r\nV::Array{Float}: v velocity component of the inflow at each r\nW::Array{Float}: w velocity component of the inflow at each r\nOmega::Float: rotor rotational speed\nr::Array{Float}: radial locations of interest\nprecone::Float: rotor precone angle\nyaw::Float: rotor yaw angle\ntilt::Float: rotor tilt angle\nazimuth::Float: blade azimuth angle\nrho::Float: air density\n\nKeyword Arguments\n\nmu::Float: air viscocity (can usually use the default)\nasound::Float: speed of sound (can usually use the default)\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.point_velocity-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}","page":"Reference","title":"FLOWFarm.point_velocity","text":"point_velocity(loc, turbine_x, turbine_y, turbine_z, turbine_yaw, turbine_ct, turbine_ai,\nrotor_diameter, hub_height, turbine_local_ti, sorted_turbine_index, wtvelocities,\nwind_resource, model_set::AbstractModelSet;\nwind_farm_state_id=1, downwind_turbine_id=0)\n\nCalculates the wind speed at a given point for a given state\n\nArguments\n\nloc::Array{TF,3}: Location of interest\nturbine_x::Array{TF,nTurbines}: turbine east-west locations in the state    reference frame\nturbine_y::Array{TF,nTurbines}: turbine north-south locations in the state    reference frame\nturbine_z::Array{TF,nTurbines}: turbine base height in the state reference frame\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in    radians\nturbine_ct::Array{TF,nTurbines}: turbine thrust coefficients for the given state\nturbine_ai::Array{TF,nTurbines}: turbine axial induction for the given state\nrotor_diameter::Array{TF,nTurbines}: turbine rotor diameters\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_local_ti::Array{TF,nTurbines}: turbine local turbulence intensity for    the given state\nsorted_turbine_index::Array{TF,nTurbines}: array containing indices of wind turbines    from most upwind to most downwind turbine in the given state\nwtvelocities::Array{TF,nTurbines}: effective inflow wind speed for given state\nwind_resource::DiscretizedWindResource: contains wind resource discreption (directions,   speeds, frequencies, etc)\nwind_farm_state_id::Int: index to correct state to use from wind resource provided.   Defaults to 1\ndownwind_turbine_id::Int: index of wind turbine of interest (if any). If not a point for   calculating effective wind speed of a turbine, then provide 0 (default)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.print_layout_in_cartesian_frame_excel-NTuple{5, Any}","page":"Reference","title":"FLOWFarm.print_layout_in_cartesian_frame_excel","text":"print_state_layouts_in_cartesian_frame(turbinex, turbiney, winddirections)\n\nGiven a wind farm layout in the global reference frame, print the layout rotated to the  cartesian frame with wind to the positive x axis (right) for all wind directions.\n\nArguments\n\nturbinex::Array{T,1}: x locations of turbines in global reference frame \nturbiney::Array{T,1}: y locations of turbines in global reference frame\nwinddirections::Array{T,1}: all wind directions in radians in meteorological coordinates (0 rad. = from North)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.rainflow","page":"Reference","title":"FLOWFarm.rainflow","text":"rainflow(array_ext,uc_mult=0.5)\n\nRainflow counting of a signal's turning points\n\nArguments\n\n    array_ext (numpy.ndarray): array of turning points\n\nKeyword Arguments\n\n    uc_mult (float): partial-load scaling [opt, default=0.5]\n\nReturns\n\n    array_out (numpy.ndarray): (3 x n_cycle) array of rainflow values:\n                                1) load range\n                                2) range mean\n                                3) cycle count\n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.ray_casting_boundary-NTuple{4, Any}","page":"Reference","title":"FLOWFarm.ray_casting_boundary","text":"ray_casting_boundary(boundary_vertices,boundary_normals,turbine_x,turbine_y)\n\nCalculate the distance from each turbine to the nearest point on the boundary using  the ray-casting algorithm. Negative means the turbine is inside the boundary.\n\nArguments\n\nboundary_vertices::Array{Float,2}: vertices of the boundary CCW in order s.t.       boundaryVertices[i] -> first point of face for unit_normals[i]\nboundary_normals::Array{Float,2}: unit normal vector for each boundary face       CCW where boundaryVertices[i] is the first point of the corresponding face\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.rotate_to_wind_direction-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm.rotate_to_wind_direction","text":"rotate_to_wind_direction(xlocs, ylocs, wind_direction_met)\n\nRotates wind farm coordinates to be in wind direction reference where wind direction is to the positive x.\n\nArguments\n\nxlocs::Array: contains turbine east-west locations in the global reference frame\nylocs::Array: contains turbine north-south locations in the global reference frame\nwind_direction_met::Array: contains wind direction in radians in meteorological standard    system (N=0 rad, proceeds CW, wind from direction given)\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.rotor_sample_points","page":"Reference","title":"FLOWFarm.rotor_sample_points","text":"rotor_sample_points(nsamplepoints=1)\n\nInitializes the sampling locations in the rotor-swept-area. Returns values such that zero is at the turbine hub location and 1 is at the tip of the blades. If a single sample is requested, it will be at the hub location. Otherwise, the points will be located using the sunflower packcing algorithm.\n\nArguments\n\nnsamplepoints::Int: controlls how many sample points to generate\nalpha::Float: Controls smoothness of the sunflower algorithm boundary. alpha=0 is the standard \"jagged edge\" sunflower algoirthm and   alpha=1 results in a smooth boundary.\npradius::Float: the percent of the rotor radius to use in generating initial point grid \nuse_perimeter_points: whether or not to include point exactly on the perimeter of the    rotor swept area \n\n\n\n\n\n","category":"function"},{"location":"Reference/#FLOWFarm.smooth_max-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.smooth_max","text":"smooth_max_ndim(x; s=100.0)\n\nCalculate the smoothmax (a.k.a. softmax or LogSumExponential) of the elements in x.\n\nBased on John D. Cook's writings at  (1) https://www.johndcook.com/blog/2010/01/13/soft-maximum/ and (2) https://www.johndcook.com/blog/2010/01/20/how-to-compute-the-soft-maximum/\n\nArguments\n\nx::Float: first value for comparison\ny::Float: second value for comparison\ns::Float : controls the level of smoothing used in the smooth max\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.smooth_max-Tuple{Any}","page":"Reference","title":"FLOWFarm.smooth_max","text":"smooth_max(x; s=10.0)\n\nCalculate the smoothmax (a.k.a. softmax or LogSumExponential) of the elements in x.\n\nBased on John D. Cook's writings at  (1) https://www.johndcook.com/blog/2010/01/13/soft-maximum/ and (2) https://www.johndcook.com/blog/2010/01/20/how-to-compute-the-soft-maximum/\n\nAnd based on article in FeedlyBlog (3) https://blog.feedly.com/tricks-of-the-trade-logsumexp/\n\nArguments\n\nx::Array{Float,1} : vector with all the input values\ns::Float : controls the level of smoothing used in the smooth max\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.splined_boundary-NTuple{5, Any}","page":"Reference","title":"FLOWFarm.splined_boundary","text":"splined_boundary(turbine_x, turbine_y, bndry_x_clsd, bndry_y_clsd, bndry_corner_indcies)\n\ncalculate the distance from each turbine to a closed boundary made up of zero or more reflex angles (concavities). Boundary will have three or four user-selected \"corners\", such that the \"sides\" between corners (that will be splined) are injective functions (meaning that for every x-coord, there exists only one corresponding y-coord). Returns four values for every turbine, corresponding to the distance from the turb to the upper, lower, left, and right splined \"sides\". A negative return value means the turb is inside the boundary for that \"side\". Returns a single array of {Float64} of length {length(turbine_x) * 4}. Note that all boundary coordinates must be in the first quadrant of the Cartesian coordinate system (+x and +y values only)\n\nArguments\n\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\nbndry_x_clsd::Array{Float}: x locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.\nbndry_y_clsd::Array{Float}: y locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.\nbndry_corner_indcies::Array{Float}: An array of 3 or 4 indicies in the       bndryx/yclsd arrays that correspond to the three four \"corners\" used       between splined \"sides\"\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.splined_boundary_discreet_regions-NTuple{7, Any}","page":"Reference","title":"FLOWFarm.splined_boundary_discreet_regions","text":"splined_boundary_discreet_regions(turbine_x, turbine_y, bndry_x_clsd, bndry_y_clsd, bndry_corner_indcies, turbs_per_region)\n\nUses FLOWFarm's splinedboundary() function to calculate the turbine-boundary constraints for one or more discreet regions, with pre-allocated turbines for each region. Returns four values for every turbine, corresponding to the distance from each turb to the upper, lower, left, and right splined \"sides\" for the region to which it was allocated. A negative return value means the turb is outside the \"side\" of boundary for which it has been allocated. Returns a single array of {Float64} of length {length(turbinex) * 4}. Note that all boundary coordinates must be in the first quadrant of the Cartesian coordinate system (+x and +y values only)\n\nArguments\n\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\nbndry_x_clsd::Array{Float}: x locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.\nbndry_y_clsd::Array{Float}: y locations of boundary vertices, CCW in       order s.t. boundaryVertices[0] is the NE corner of boundary, and with       the first vertex duplicated at the end for completeness of calcs.\nbndry_corner_indcies::Array{Float}: An array of 3 or 4 indicies in the       bndryx/yclsd arrays that correspond to the three four \"corners\" used       between splined \"sides\"\n'turbsperregion::Array{Int}`: An array of length equivalent to the number of       discrete boundary regions, with each element denoting howmany turbines       are apportioned to the corresponding region. sum(turbsperregion) must       be equivalent to the total number of turbines in the windfarm\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.sunflower_points-Tuple{Any}","page":"Reference","title":"FLOWFarm.sunflower_points","text":"sunflower_points(n; alpha=0.0)\n\nGenerates points in a circle of radius=1 using the sunflower packing algorithm. \n\nArguments\n\nn::Float: number of points to generate\nalpha::Float: Controls the smoothness of the boundary. alpha=0 is the standard \"jagged edge\" sunflower algoirthm and   alpha=1 results in a smooth boundary.\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.turbine_powers_one_direction-NTuple{10, Any}","page":"Reference","title":"FLOWFarm.turbine_powers_one_direction","text":"turbine_powers_one_direction((generator_efficiency, cut_in_speed, cut_out_speed, \n    rated_speed, rated_power, rotor_diameter, turbine_inflow_velcities, air_density, power_model::AbstractPowerModel)\n\nCalculate the power for all wind turbines for a given state\n\nArguments\n\ngenerator_efficiency::Array{Float,nTurbines}\ncut_in_speed::Array{Float,nTurbines} \ncut_out_speed::Array{Float,nTurbines}\nrated_speed::Array{Float,nTurbines}\nrated_power::Array{Float,nTurbines}\nrotor_diameter::Array{Float,nTurbines}\nturbine_inflow_velcities::Array{Float,nTurbines}: for current state only\nair_density::Float\npower_models::Array{nturbines}) elements of array should be be of sub-types or AbstractPowerModel\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.turbine_spacing-Tuple{Any, Any}","page":"Reference","title":"FLOWFarm.turbine_spacing","text":"turbine_spacing(turbine_x,turbine_y)\n\nCalculate the distance between turbines in a wind farm. There is an infinite gradient of this function if two points are exactly the same. This can be avoided by returning the square of the turbine spacing rather than the actual distance, but it makes the gradients scale much more poorly. Because it is very vanishingly rare to have turbines exactly in the same location, this function leaves the square root in the calculations.\n\nArguments\n\nturbine_x::Array{Float}: turbine x locations\nturbine_y::Array{Float}: turbine y locations\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.turbine_velocities_one_direction-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.AbstractModelSet}","page":"Reference","title":"FLOWFarm.turbine_velocities_one_direction","text":"point_velocity(turbine_x, turbine_y, turbine_z, rotor_diameter, hub_height, turbine_yaw,\nsorted_turbine_index, ct_model, rotor_sample_points_y, rotor_sample_points_z, wind_resource,\nmodel_set::AbstractModelSet; wind_farm_state_id=1)\n\nCalculates the wind speed at a given point for a given state\n\nArguments\n\nturbine_x::Array{TF,nTurbines}: turbine east-west locations in the state    reference frame\nturbine_y::Array{TF,nTurbines}: turbine north-south locations in the state    reference frame\nturbine_z::Array{TF,nTurbines}: turbine base height in the state reference frame\nrotor_diameter::Array{TF,nTurbines}: turbine rotor diameters\nhub_height::Array{TF,nTurbines}: turbine hub heights\nturbine_yaw::Array{TF,nTurbines}: turbine yaw for the given wind direction in    radians\nsorted_turbine_index::Array{TF,nTurbines}: turbine sorted order upstream to downstream    for given state\nct_model::AbstractThrustCoefficientModel: defines how the thrust coefficient changes    with state etc\nrotorsamplepoints_y::Array{TF,N}`: horizontal wind location of points to sample across    the rotor swept area when calculating the effective wind speed for the wind turbine.    Points are centered at the hub (0,0) and scaled by the radius (1=tip of blades) \nrotorsamplepoints_z::Array{TF,N}`: vertical wind location of points to sample across the    rotor swept area when calculating the effective wind speed for the wind turbine. Points   are centered at the hub (0,0) and scaled by the radius (1=tip of blades)\nwind_resource::DiscretizedWindResource: wind resource discreption (directions, speeds,    frequencies, etc)\nmodel_set::AbstractModelSet: defines wake-realated models to be used in analysis\nwind_farm_state_id::Int: index to correct state to use from wind resource provided.   Defaults to 1\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_count_iec-Tuple{Any, Any, Real, Any}","page":"Reference","title":"FLOWFarm.wake_count_iec","text":"wake_count_iec(turbinex, turbiney, winddirection, diameter; return_turbines=true)\n\nAdapted from NREL's floris\n\nFinds the number of turbines waking each turbine for the given\nwind direction. Waked directions are determined using the formula\nin Figure A.1 in Annex A of the IEC 61400-12-1:2017 standard.\n\nArguments\n\nturbinex::Array{T,1}: x locations of turbines in global reference frame \nturbiney::Array{T,1}: y locations of turbines in global reference frame\nwinddirection::Float: wind direction in radians in meteorological coordinates (0 rad. = from North)\ndiameter::Array{T,1}: diameters of all wind turbines\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussOriginal}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::GaussOriginal)\n\nComputes the wake deficit at a given location using the Gaussian wake model presented by Bastankhah and Porte-Agel in the paper: \"A new analytical model for wind-turbine wakes\" (2014)\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated \nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake \ndeflection_z::Float: deflection in the z direction of downstream wake \nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::GaussOriginal: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussSimple}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::GaussSimple)\n\nComputes the wake deficit at a given location using the Gaussian wake model presented by Bastankhah and Porte-Agel in the paper: \"A new analytical model for wind-turbine wakes\" (2014)     as modified for IEA Task 37 Case Studies 3 and 4\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated \nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake \ndeflection_z::Float: deflection in the z direction of downstream wake \nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::GaussSimple: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussYawVariableSpread}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::GaussYawVariableSpread)\n\nComputes the wake deficit at a given location using the The Gaussian wake model presented by Bastankhah and Porte-Agel in the paper: \"Experimental and theoretical study of wind turbine wakes in yawed conditions\" (2016) The spread rate is adjusted based on local turbulence intensity as in Niayifar and Porte-Agel 2016\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated \nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake \ndeflection_z::Float: deflection in the z direction of downstream wake \nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::GaussYawVariableSpread: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussYaw}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::GaussYaw)\n\nComputes the wake deficit at a given location using the The Gaussian wake model presented by Bastankhah and Porte-Agel in the paper: \"Experimental and theoretical study of wind turbine wakes in yawed conditions\" (2016)\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated \nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake \ndeflection_z::Float: deflection in the z direction of downstream wake \nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::GaussYaw: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.JensenCosine}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::JensenCosine)\n\nComputes the wake deficit according to the original Jensen cosine wake model, from the paper: \"A Note on Wind Generator Interaction\" by N.O. Jensen (1983)\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated \nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake \ndeflection_z::Float: deflection in the z direction of downstream wake \nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::JensenCosine: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.JensenTopHat}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::JensenTopHat)\n\nComputes the wake deficit according to the original Jensen top hat wake model, from the paper: \"A Note on Wind Generator Interaction\" by N.O. Jensen (1983)\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated \nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake \ndeflection_z::Float: deflection in the z direction of downstream wake \nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::JensenTopHat: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deficit_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.MultiZone}","page":"Reference","title":"FLOWFarm.wake_deficit_model","text":"wake_deficit_model(locx, locy, locz, turbine_x, turbine_y, turbine_z, deflection_y, deflection_z, upstream_turbine_id, downstream_turbine_id, hub_height, rotor_diameter, turbine_ai, turbine_local_ti, turbine_ct, turbine_yaw, model::MultiZone)\n\nComputes the wake deficit at a given location using the original MultiZone \"FLORIS\" wake model, from the paper: \"Wind plant power optimization through yaw control using a parametric model for wake effectsâa CFD simulation study\" by Gebraad et al. (2014)\n\nArguments\n\nlocx::Float: x coordinate where wind speed is calculated \nlocy::Float: y coordinate where wind speed is calculated\nlocz::Float: z coordinate where wind speed is calculated\nturbine_x::Array(Float): vector containing x coordinates for all turbines in farm\nturbine_y::Array(Float): vector containing y coordinates for all turbines in farm\nturbine_z::Array(Float): vector containing z coordinates for all turbines in farm\ndeflection_y::Float: deflection in the y direction of downstream wake \ndeflection_z::Float: deflection in the z direction of downstream wake \nupstream_turbine_id::Int: index of the upstream wind turbine creating the wake\ndownstream_turbine_id::Int: index of the downstream turbine feeling the wake (if not referencing a turbine set to zero)\nhub_height::Array(Float): vector containing hub heights for all turbines in farm\nrotor_diameter::Array(Float): vector containing rotor diameters for all turbines in farm\nturbine_ai::Array(Float): vector containing initial velocity deficits for all turbines in farm\nturbine_local_ti::Array(Float): vector containing local turbulence intensities for all turbines in farm\nturbine_ct::Array(Float): vector containing thrust coefficients for all turbines in farm\nturbine_yaw::Array(Float): vector containing the yaw angle? for all turbines in farm\nmodel::MultiZone: indicates the wake model in use\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussYawDeflection}","page":"Reference","title":"FLOWFarm.wake_deflection_model","text":"wake_deflection_model(locx, locy, locz, turbine_x, turbine_yaw, turbine_ct, turbine_id, rotor_diameter, turbine_local_ti, model::GaussYawDeflection)\n\nCalculates the horizontal deflection of the wind turbine wake\n\nBased on:\n[1] Bastankhah and Porte-Agel 2016 \"Experimental and theoretical study of\nwind turbine wakes in yawed conditions\"\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.GaussYawVariableSpreadDeflection}","page":"Reference","title":"FLOWFarm.wake_deflection_model","text":"wake_deflection_model(oc, turbine_x, turbine_yaw, turbine_ct, turbine_id, rotor_diameter, turbine_local_ti, model::GaussYawVariableSpreadDeflection)\n\nCalculates the horizontal deflection of the wind turbine wake. Varies based on local turbulence intensity.\n\nBased on:\n[1] Bastankhah and Porte-Agel 2016 \"Experimental and theoretical study of\nwind turbine wakes in yawed conditions\"\n[2] Niayifar and Porte-Agel 2016 \"Analytical Modeling of Wind Farms:\nA New Approach for Power Prediction\"\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.wake_deflection_model-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, FLOWFarm.JiminezYawDeflection}","page":"Reference","title":"FLOWFarm.wake_deflection_model","text":"wake_deflection_model(locx, locy, locz, turbine_id, turbine_definition::TurbineDefinition, model::JiminezYawDeflection, windfarmstate::SingleWindFarmState)\n\nCalculates the horizontal deflection of the wind turbine wake\n\nBased on:\n[1] Jiminez 2010 \"Wake defl ection of a wind turbine in yaw\"\n[2] Gebraad 2014 \"Wind plant optimization by yaw control using a parametric wake model\"\nthis version ignores the corrections made to the yaw model for rotor rotation as described in [2] and\n[3] Thomas 2017 \"Improving the FLORIS wind plant model for compatibility with gradient-based optimization\"\n\n\n\n\n\n","category":"method"},{"location":"Reference/#FLOWFarm.write_turb_loc_YAML-Tuple{Any, Any, Any}","page":"Reference","title":"FLOWFarm.write_turb_loc_YAML","text":"write_turb_loc_YAML(file_name, data)\n\nwrite turbine locations and related information to .yaml\n\nArguments\n\nfile_name::String: path/and/name/of/location/file.yaml\n\n\n\n\n\n","category":"method"},{"location":"Tutorial/#Tutorial","page":"Quick Start","title":"Tutorial","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"This tutorial covers the basics of FlowFARM. For more specifics refer to the How-to guide.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"There are three main steps to setting up and running an analysis in FLOWFarm:","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"(1) setting up the problem description\n(2) setting up the analysis model set\n(3) running the analysis","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Details for setting up an optimization will depend heavily on the optimization package you are using, your objective, and your design variables. Optimization examples using various packages are provided in the example scripts located in the test  directory.","category":"page"},{"location":"Tutorial/#(1)-Setting-up-the-problem-description","page":"Quick Start","title":"(1) Setting up the problem description","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"import FLOWFarm; const ff = FLOWFarm\n\n# define the rotor diameter\ndiameter = 80.0\n\n# set initial turbine x and y locations\nturbine_x = [-3.0, 0.0, 3.0, 0.0, 0.0, -1.5, 0.0, 1.5, 0.0].*diameter\nturbine_y = [0.0, 3.0, 0.0, -3.0, 0.0, 0.0, 1.5, 0.0, -1.5].*diameter\n\n# calculate the number of turbines\nnturbines = length(turbine_x)\n\n# set turbine base heights\nturbine_z = zeros(nturbines)\n\n# set turbine yaw values\nturbine_yaw = zeros(nturbines)\n\n# set turbine design parameters\nrotor_diameter = zeros(nturbines) .+ diameter   # m\nhub_height = zeros(nturbines) .+ 70.0           # m\ncut_in_speed = zeros(nturbines) .+4.            # m/s\ncut_out_speed = zeros(nturbines) .+25.          # m/s\nrated_speed = zeros(nturbines) .+16.            # m/s\nrated_power = zeros(nturbines) .+2.0E6          # W\ngenerator_efficiency = zeros(nturbines) .+ 0.944\n\n# Rotor swept area sample points (normalized by rotor radius). These arrays define which\n# which points on the rotor swept area should be used to estimate the effective inflow\n# wind speed for each wind turbine. Values of 0.0 are at the rotor hub, 1.0 is at the blade\ntip. z is vertical, and y is horizontal. These points track the rotor yaw.\nrotor_points_y = [0.0]\nrotor_points_z = [0.0]\n\n# set flow parameters\nwind_speed = 8.0        # m/2\nair_density = 1.1716    # kg/m^3\nambient_ti = 0.077      # %\nshearexponent = 0.15\nwinddirections = [275.0*pi/180.0, 0.0, pi]          # radians\nwindspeeds = [wind_speed, wind_speed, wind_speed]   # m/s\nwindprobabilities = [1.0/3.0,1.0/3.0,1.0/3.0]       # %\nambient_tis = [ambient_ti, ambient_ti, ambient_ti]  # %\nmeasurementheight = [hub_height[1], hub_height[1], hub_height[1]]   # m\n\n# initialize the wind shear model\nwind_shear_model = ff.PowerLawWindShear(shearexponent)\n\n# initialize the wind resource definition\nwindresource = ff.DiscretizedWindResource(winddirections, windspeeds, windprobabilities, \nmeasurementheight, air_density, ambient_tis, wind_shear_model)\n","category":"page"},{"location":"Tutorial/#(2)-Setting-up-the-analysis-models","page":"Quick Start","title":"(2) Setting up the analysis models","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"A model set requires a Wake Deficit Model, Wake Deflection Model, Wake Combination Model, and a Local Turbulence Intensity Model","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Deficit Models: JensenTopHat, JensenCosine, MultiZone, GaussOriginal, GaussYaw, GaussYawVariableSpread, GaussSimple\nDeflection Models: GaussYawDeflection, GaussYawVariableSpreadDeflection, JiminezYawDeflection, MultizoneDeflection\nCombination Models: LinearFreestreamSuperposition, SumOfSquaresFreestreamSuperposition, SumOfSquaresLocalVelocitySuperposition, LinearLocalVelocitySuperposition\nTurbulence Models: LocalTIModelNoLocalTI, LocalTIModelMaxTI","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The model set can be set up as follows:","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Initialize power model (this is a simple power model based only on turbine design and is not accurate. For examples on how to use more accurate power models, look at the example optimization scripts)","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"power_model = ff.PowerModelPowerCurveCubic()","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The user can define different power models for different wind turbines, but here we use the same power model for every turbine. The initialization of the power_models vector is important for optmization using algorithmic differentiation via the ForwardDiff.jl package.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"power_models = Vector{typeof(power_model)}(undef, nturbines)\nfor i = 1:nturbines\n    power_models[i] = power_model\nend","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Initialize thrust model. The user can provide a complete thrust curve. See the example scripts for details on initializing them. The initialization of ct_models vector is important for optmization using algorithmic differentiation via the ForwardDiff.jl package.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"ct_model = ff.ThrustModelConstantCt(0.65)\nct_models = Vector{typeof(ct_model)}(undef, nturbines)\nfor i = 1:nturbines\n    ct_models[i] = ct_model\nend","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Set up wake and related models. Here we will use the default values provided in FLOWFarm. However, it is important to use the correct model parameters. More information and references are provided in the doc strings attached to each model.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The wake deficit model predicts the impact of wind turbines wake on the wind speed.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"wakedeficitmodel = ff.GaussYaw()","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The wake deflection model predicts the cross-wind location of the center of a wind turbine wake.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"wakedeflectionmodel = ff.GaussYawDeflection()","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The wake combination model defines how the predicted deficits in each wake should be combined to predict the total deficit at a point","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"wakecombinationmodel = ff.LinearLocalVelocitySuperposition()","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"The local turbulence intensity models can be used to estimate the local turbulence intensity at each wind turbine or point to provide more accurate input information to the wake and deflection models if applicable.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"localtimodel = ff.LocalTIModelMaxTI()","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Initialize model set. This is just a convenience container for the analysis models.","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"model_set = ff.WindFarmModelSet(wakedeficitmodel, wakedeflectionmodel, wakecombinationmodel, localtimodel)","category":"page"},{"location":"Tutorial/#(3)-Running-the-analysis","page":"Quick Start","title":"(3) Running the analysis","text":"","category":"section"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"Calculate AEP","category":"page"},{"location":"Tutorial/","page":"Quick Start","title":"Quick Start","text":"\n    AEP = ff.calculate_aep(turbine_x, turbine_y, turbine_z, rotor_diameter,\n        hub_height, turbine_yaw, ct_models, generator_efficiency, cut_in_speed,\n        cut_out_speed, rated_speed, rated_power, windresource, power_models, model_set,\n        rotor_sample_points_y=rotor_points_y, rotor_sample_points_z=rotor_points_z)\n","category":"page"},{"location":"Explanation/#Explanation","page":"Theory","title":"Explanation","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"This section will explain the fundamental principles behind the wind models used in Flow Farm.","category":"page"},{"location":"Explanation/#Wake-Deficit-Models","page":"Theory","title":"Wake Deficit Models","text":"","category":"section"},{"location":"Explanation/#Jensen","page":"Theory","title":"Jensen","text":"","category":"section"},{"location":"Explanation/#Top-Hat","page":"Theory","title":"Top Hat","text":"","category":"section"},{"location":"Explanation/#Cosine","page":"Theory","title":"Cosine","text":"","category":"section"},{"location":"Explanation/#MultiZone","page":"Theory","title":"MultiZone","text":"","category":"section"},{"location":"Explanation/#Bastankah","page":"Theory","title":"Bastankah","text":"","category":"section"},{"location":"Explanation/#Wake-Deflection-Models","page":"Theory","title":"Wake Deflection Models","text":"","category":"section"},{"location":"Explanation/#Jimenez","page":"Theory","title":"Jimenez","text":"","category":"section"},{"location":"Explanation/#MultiZone-2","page":"Theory","title":"MultiZone","text":"","category":"section"},{"location":"Explanation/#Gauss","page":"Theory","title":"Gauss","text":"","category":"section"},{"location":"Explanation/#Wake-Combination-Models","page":"Theory","title":"Wake Combination Models","text":"","category":"section"},{"location":"Explanation/#Katic","page":"Theory","title":"Katic","text":"","category":"section"},{"location":"Explanation/#Whatever-Else-there-is","page":"Theory","title":"Whatever Else there is","text":"","category":"section"},{"location":"Explanation/#Local-Turbulence-Intensity","page":"Theory","title":"Local Turbulence Intensity","text":"","category":"section"},{"location":"Explanation/#Power-Models","page":"Theory","title":"Power Models","text":"","category":"section"},{"location":"Explanation/#AEP","page":"Theory","title":"AEP","text":"","category":"section"},{"location":"Explanation/#Wind-Shear","page":"Theory","title":"Wind Shear","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"Wind shear refers to the fact that the wind speed changes with elevation. For wind farms, that change is due to the boundary layer of the wind flowing over the earth. The boundary layer is the region where the flow transitions from stationary at the ground, to some free-stream speed at some distance above the ground. ","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"Wind shear in FLOWFarm is handled using a power law","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"u = u_r bigfracz-z_0z_r-z_0big^phi","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"where u is the wind speed at the desired height (z), z_r is the height of the known speed (u_r), and z_0 is the height of the ground (which is zero for flat terrain). The value of phi controls how quickly the wind speed transitions from zero to the free-stream velocity.","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"The models used by FLOWFarm are simple engineering models and do not account for wind shear. To apply wind shear, we first adjust the inflow speed using the wind shear equation and then apply the wake deficit for the given point. ","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"using FLOWFarm; const ff = FLOWFarm\n\n# set input values\nshear_exponent = 0.15\nlocz = 40.0 # height above ground in meters\nreference_velocity = 8.0 # in m/s\nreference_height = 80.0 # height of reference velocity in meters\nground_height = 0.0 # height where velocity goes to zero\n\n# initialize wind shear model instance\nwind_shear_model = ff.PowerLawWindShear(shear_exponent)\n\n# adjust wind speed for wind shear\nff.adjust_for_wind_shear(locz, reference_velocity, reference_height, ground_height, wind_shear_model)\n\n# output\n7.2100037008866416","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"using FLOWFarm; const ff = FLOWFarm\nusing PyPlot; const plt = PyPlot\n\n# set input values\nshear_exponent = 0.15\nlocz = 40.0 # height above ground in meters\nreference_velocity = 8.0 # in m/s\nreference_height = 80.0 # height of reference velocity in meters\nground_height = 0.0 # height where velocity goes to zero\n\n# initialize wind shear model instance\nwind_shear_model = ff.PowerLawWindShear(shear_exponent)\n\nh = 0:100\ns = zeros(length(h))\nfor i in length(h)\n    s[i] = ff.adjust_for_wind_shear(h[i], reference_velocity, reference_height, ground_height, wind_shear_model)\nend\n\n# Scatter plot with some custom settings\nplt.scatter(s, h)\nplt.title(\"Wind Shear\")\nplt.xlabel(\"Speed (m/s)\")\nplt.ylabel(\"Height (m)\")\n","category":"page"},{"location":"Explanation/#Other-Functions","page":"Theory","title":"Other Functions","text":"","category":"section"},{"location":"Explanation/#Overlap","page":"Theory","title":"Overlap","text":"","category":"section"},{"location":"Explanation/#Optimization","page":"Theory","title":"Optimization","text":"","category":"section"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"Citing:","category":"page"},{"location":"Explanation/","page":"Theory","title":"Theory","text":"N.O. Jensen \"A Note on Wind Generator Interaction\" Roskilde: RisÃ¸ National Laboratory (1983)\nI. Katic, k. HÃ¸lstrup, N.O. Jensen. \"A simple model for cluster efficiency\"* European Wind Energy Association Conference and exhibition* (1986) \nGebraad et al. \"Wind plant power optimization through yaw control using a parametric model for wake effectsâa CFD simulation study\" (2014) \nJimenez et al. \"Application of a LES technique to characterize the wake deflection of a wind turbine in yaw\" Wind Energy (2010)\nBastankhah \"A new analytical model for wind-turbine wakes\" Renewable Energy (2014)\nBastankhah \"Experimental and theoretical study of wind turbine wakes in yawed conditions\" Journal of Fluid Mechanics (2016)\nNiayifar \"Analytical modeling of wind farms: A new approach for power prediction\" Energies (2016)\nThomas \"Improving the FLORIS Wind Plant Model for Compatibility with Gradient-Based Optimization\" Wind Engineering (2017)\nThomas \"Comparison of Wind Farm Layout Optimization Results Using a Simple Wake Model and Gradient-Based Optimization to Large-Eddy Simulations\" AIAA Scitech 2019 Forum (2019)\nThomas, McOmber, and Ning \"Wake Expansion Continuation: Multi-Modality Reduction in the Wind Farm Layout Optimization Problem\" Wind Energy (in review), â>","category":"page"},{"location":"#FLOWFarm.jl","page":"Intro","title":"FLOWFarm.jl","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Summary: Wind farm simulation tool for gradient-based optimization.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Authors: Jared J. Thomas, Andrew P.J. Stanley","category":"page"},{"location":"#Features","page":"Intro","title":"Features","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Swap out models without changing anything else in the simulation setup\nSmooth/continous model implementations\nRuns on a single core, across multiple cores (threaded), or on multiple machines (distributed).\nDesigned so that new model implementations can be included by adding a single method\nAllows for Wake Expansion Continuation (WEC) as described here","category":"page"},{"location":"#Installation","page":"Intro","title":"Installation","text":"","category":"section"},{"location":"#Install-FLOWFarm","page":"Intro","title":"Install FLOWFarm","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"(v1.x) pkg> dev https://github.com/byuflowlab/FLOWFarm.jl.git","category":"page"},{"location":"#Enable-NaN-Safe-Mode-in-ForwardDiff","page":"Intro","title":"Enable NaN Safe Mode in ForwardDiff","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"NaN Safe Mode must be enables in ForwardDiff for ForwardDiff to work properly with FLOWFarm.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"(v1.x) pkg> dev ForwardDiff","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"$ cd ~/.julia/dev/ForwardDiff/src/","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"In prelude.jl, on the first line, set const NANSAFE_MODE_ENABLED = true and save the file.  For more information see the ForwardDiff documentation at  http://www.juliadiff.org/ForwardDiff.jl/latest/user/advanced.html","category":"page"},{"location":"#Testing","page":"Intro","title":"Testing","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"To test FLOWFarm, run the following from the top directory:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"]\nactivate .\ntest","category":"page"},{"location":"#Documentation","page":"Intro","title":"Documentation","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Begin with the quick start tutorial.\nMore advanced topics are covered in the guided examples.\nTheory details, and links, can be found in the theory page.\nDoc strings can be found in the references page.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Citing: Thomas, McOmber, and Ning \"Wake Expansion Continuation: Multi-Modality Reduction in the Wind Farm Layout Optimization Problem\" Wind Energy (in review), â>","category":"page"}]
}
