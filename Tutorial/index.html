<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quick Start · FLOWFarm.jl</title><meta name="title" content="Quick Start · FLOWFarm.jl"/><meta property="og:title" content="Quick Start · FLOWFarm.jl"/><meta property="twitter:title" content="Quick Start · FLOWFarm.jl"/><meta name="description" content="Documentation for FLOWFarm.jl."/><meta property="og:description" content="Documentation for FLOWFarm.jl."/><meta property="twitter:description" content="Documentation for FLOWFarm.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FLOWFarm.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Intro</a></li><li class="is-active"><a class="tocitem" href>Quick Start</a><ul class="internal"><li><a class="tocitem" href="#(1)-Setting-up-the-problem-description"><span>(1) Setting up the problem description</span></a></li><li><a class="tocitem" href="#(2)-Setting-up-the-analysis-models"><span>(2) Setting up the analysis models</span></a></li><li><a class="tocitem" href="#(3)-Running-the-analysis"><span>(3) Running the analysis</span></a></li><li><a class="tocitem" href="#(4)-setting-up-and-running-an-optimization"><span>(4) setting up and running an optimization</span></a></li><li><a class="tocitem" href="#(5)-Calculating-a-flow-field"><span>(5) Calculating a flow field</span></a></li></ul></li><li><a class="tocitem" href="../WindFarmStruct/">Wind Farm Struct</a></li><li><a class="tocitem" href="../How_to/">How-to Guide</a></li><li><a class="tocitem" href="../Explanation/">Theory</a></li><li><a class="tocitem" href="../Reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Quick Start</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quick Start</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/byuflowlab/FLOWFarm.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/byuflowlab/FLOWFarm.jl/blob/master/docs/src/Tutorial.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>This tutorial covers the basics of FlowFARM. For more specifics refer to the <a href="../How_to/">How-to guide</a>.</p><p>This tutorial discusses how to do the following with FLOWFarm:</p><ul><li>(1) setting up a problem description</li><li>(2) setting up an analysis model set</li><li>(3) running analyses</li><li>(4) setting up and running an optimization</li><li>(5) calculating and visualizing a flow field</li></ul><p>Details for setting up an optimization will depend heavily on the optimization package you are using, your objective, and your design variables. Optimization examples using various packages are provided in the example scripts located in the test  directory.</p><h2 id="(1)-Setting-up-the-problem-description"><a class="docs-heading-anchor" href="#(1)-Setting-up-the-problem-description">(1) Setting up the problem description</a><a id="(1)-Setting-up-the-problem-description-1"></a><a class="docs-heading-anchor-permalink" href="#(1)-Setting-up-the-problem-description" title="Permalink"></a></h2><p>The problems description involves the physical description of the wind farm, the turbines,  and the wind resource. While this tutorial uses the same design across all the wind turbines and mostly equal properties across all wind flow states, all turbines and flow states can  be unique.</p><p>For API demonstration purposes, we have directly assigned all values. However, values may  be loaded from .csv and/or .yaml files.</p><h3 id="Set-up-the-running-environment"><a class="docs-heading-anchor" href="#Set-up-the-running-environment">Set up the running environment</a><a id="Set-up-the-running-environment-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-running-environment" title="Permalink"></a></h3><pre><code class="language-julia hljs">using FLOWFarm; const ff = FLOWFarm
using SNOW</code></pre><h3 id="Initialize-the-wind-farm-design"><a class="docs-heading-anchor" href="#Initialize-the-wind-farm-design">Initialize the wind farm design</a><a id="Initialize-the-wind-farm-design-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-the-wind-farm-design" title="Permalink"></a></h3><pre><code class="language-julia hljs"># set initial turbine x and y locations
turbinex = [-240.0, -240.0, -240.0, 0.0, 0.0, 0.0, 240.0, 240.0, 240.0]
turbiney = [-240.0, 0.0, 240.0, -240.0, 0.0, 240.0, -240.0, 0.0, 240.0]

# get the number of turbines
nturbines = length(turbinex)

# set turbine base heights
turbinez = zeros(nturbines)

# set turbine yaw values
turbineyaw = zeros(nturbines)

# set wind farm boundary parameters in meters (we won&#39;t really need this until we optimize)
boundarycenter = [0.0,0.0]
boundaryradius = hypot(300, 300)</code></pre><h3 id="Initialize-wind-turbine-design"><a class="docs-heading-anchor" href="#Initialize-wind-turbine-design">Initialize wind turbine design</a><a id="Initialize-wind-turbine-design-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-wind-turbine-design" title="Permalink"></a></h3><pre><code class="language-julia hljs"># set turbine design parameters (these values correspond to the Vestas V80 turbine)
rotordiameter = zeros(nturbines) .+ 80.0   # m
hubheight = zeros(nturbines) .+ 70.0           # m
cutinspeed = zeros(nturbines) .+ 4.0           # m/s
cutoutspeed = zeros(nturbines) .+ 25.0         # m/s
ratedspeed = zeros(nturbines) .+ 16.0          # m/s
ratedpower = zeros(nturbines) .+ 2.0E6         # W
generatorefficiency = ones(nturbines)</code></pre><h3 id="Determine-how-to-sample-the-flow-field-to-determine-effective-inflow-speeds"><a class="docs-heading-anchor" href="#Determine-how-to-sample-the-flow-field-to-determine-effective-inflow-speeds">Determine how to sample the flow field to determine effective inflow speeds</a><a id="Determine-how-to-sample-the-flow-field-to-determine-effective-inflow-speeds-1"></a><a class="docs-heading-anchor-permalink" href="#Determine-how-to-sample-the-flow-field-to-determine-effective-inflow-speeds" title="Permalink"></a></h3><p>Rotor swept area sample points are normalized by the rotor radius. These arrays define which which points on the rotor swept area should be used to estimate the effective inflow wind speed for each wind turbine. Values of 0.0 are at the rotor hub, 1.0 is at the blade tip, <code>z</code> is vertical, and <code>y</code> is horizontal. These points track the rotor when yawed.  A single sample point will always be placed at the hub. More points can be arranged in  either a grid pattern or a sunflower packing pattern with various options.  See doc strings for more information.</p><pre><code class="language-julia hljs"># get the sample points
nsamplepoints = 50
rotorsamplepointsy, rotorsamplepointsz = ff.rotor_sample_points(nsamplepoints, method=&quot;sunflower&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([-0.07410836062639709, 0.015218865228956489, 0.13673646546308013, -0.2618432050129595, 0.25440179343349323, -0.08653476830049676, -0.16701958726816815, 0.3656303187083795, -0.38303743548855274, 0.1856809233100207  …  -0.4817598863166705, 0.8830705168069845, -0.8243825104580116, 0.32586882131681083, 0.3574932865011348, -0.8663755084100319, 0.9262022154807192, -0.49530244582727084, -0.20782082756188439, 0.8152470554454784], [0.06788932895734043, -0.1734111197246969, 0.17834850579052913, -0.046316376106210956, -0.16182959681996725, 0.321905024791926, -0.3215860519081978, 0.13352760597105143, 0.15811228520113338, -0.3967893479390924  …  -0.765564647902427, 0.24201301768723907, 0.42305949349566085, -0.8789751930978891, 0.8781733593639224, -0.41059152161141643, -0.28555804214300595, 0.8451458139004672, -0.9677853498733453, 0.5791133210240265])</code></pre><h3 id="Setting-up-the-wind-resource"><a class="docs-heading-anchor" href="#Setting-up-the-wind-resource">Setting up the wind resource</a><a id="Setting-up-the-wind-resource-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-wind-resource" title="Permalink"></a></h3><p>The wind resource determines the properties of the flowfield at all wind states. A wind  state is any combination of wind speed, wind direction, turbulence intensity, etc...</p><pre><code class="language-julia hljs"># set flow parameters
windspeed = 8.0        # m/2
airdensity = 1.1716    # kg/m^3
ambientti = 0.1      # %
shearexponent = 0.15
ndirections = 5
winddirections = collect(range(0, 2*pi*(1-1/ndirections), length=ndirections))   # radians
windspeeds = ones(ndirections).*windspeed   # m/s
windprobabilities = ones(ndirections).*(1.0/ndirections)       # %
ambienttis = ones(ndirections).*ambientti  # %
measurementheight = ones(ndirections).*hubheight[1] # m

# initialize the wind shear model
windshearmodel = ff.PowerLawWindShear(shearexponent)

# initialize the wind resource definition
windresource = ff.DiscretizedWindResource(winddirections, windspeeds, windprobabilities,
measurementheight, airdensity, ambienttis, windshearmodel)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DiscretizedWindResource{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, PowerLawWindShear{Float64, Float64, String}}([0.0, 1.2566370614359172, 2.5132741228718345, 3.7699111843077517, 5.026548245743669], [8.0, 8.0, 8.0, 8.0, 8.0], [0.2, 0.2, 0.2, 0.2, 0.2], [70.0, 70.0, 70.0, 70.0, 70.0], 1.1716, [0.1, 0.1, 0.1, 0.1, 0.1], PowerLawWindShear{Float64, Float64, String}(0.15, 0.0, &quot;first&quot;))</code></pre><h2 id="(2)-Setting-up-the-analysis-models"><a class="docs-heading-anchor" href="#(2)-Setting-up-the-analysis-models">(2) Setting up the analysis models</a><a id="(2)-Setting-up-the-analysis-models-1"></a><a class="docs-heading-anchor-permalink" href="#(2)-Setting-up-the-analysis-models" title="Permalink"></a></h2><p>A model set requires a Wake Deficit Model, Wake Deflection Model, Wake Combination Model, and a Local Turbulence Intensity Model. There are several options for each model type. To facilitate research studies, any of the models in each type can be used with any of the models in any other type. However, behavior is not guaranteed. It is recommended that common, validated, model combinations be used in most cases.</p><p>Model types and options are:</p><ul><li>Deficit Models: JensenTopHat, JensenCosine, MultiZone, GaussOriginal, GaussYaw, GaussYawVariableSpread, GaussSimple</li><li>Deflection Models: GaussYawDeflection, GaussYawVariableSpreadDeflection, JiminezYawDeflection, MultizoneDeflection</li><li>Combination Models: LinearFreestreamSuperposition, SumOfSquaresFreestreamSuperposition SumOfSquaresLocalVelocitySuperposition, LinearLocalVelocitySuperposition</li><li>Turbulence Models: LocalTIModelNoLocalTI, LocalTIModelMaxTI</li></ul><p>The model set can be set up as follows:</p><p>Initialize power model (this is a simple power model based only on turbine design and is not very accurate. For examples on how to use more accurate power models, look at the example optimization scripts)</p><pre><code class="language-julia hljs">powermodel = ff.PowerModelPowerCurveCubic()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PowerModelPowerCurveCubic{Int64}(2)</code></pre><p>The user can define different power models for different wind turbines, but here we use the same power model for every turbine. The initialization of the power_models vector is important for optmization using algorithmic differentiation via the ForwardDiff.jl package.</p><pre><code class="language-julia hljs">powermodels = Vector{typeof(powermodel)}(undef, nturbines)
for i = 1:nturbines
    powermodels[i] = powermodel
end</code></pre><p>Initialize thrust model(s). The user can provide a complete thrust curve. See the example scripts for details on initializing them. The initialization of the ct models vector is important for optmization using algorithmic differentiation via the ForwardDiff.jl package.</p><pre><code class="language-julia hljs">ctmodel = ff.ThrustModelConstantCt(0.65)
ctmodels = Vector{typeof(ctmodel)}(undef, nturbines)
for i = 1:nturbines
    ctmodels[i] = ctmodel
end</code></pre><p>Set up wake and related models. Here we will use the default values provided in FLOWFarm. However, it is important to use the correct model parameters. More information and references are provided in the doc strings attached to each model.</p><p>The wake deficit model predicts the impact of wind turbines wake on the wind speed.</p><pre><code class="language-julia hljs">wakedeficitmodel = ff.GaussYawVariableSpread()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GaussYawVariableSpread{Float64, Float64, Float64, Float64, Vector{Float64}, Bool}(2.32, 0.154, 0.3837, 0.003678, [1.0], true)</code></pre><p>The wake deflection model predicts the cross-wind location of the center of a wind turbine wake.</p><pre><code class="language-julia hljs">wakedeflectionmodel = ff.GaussYawDeflection()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GaussYawDeflection{Float64, Float64, Float64, Float64, Bool}(0.022, 0.022, 2.32, 0.154, true)</code></pre><p>The wake combination model defines how the predicted deficits in each wake should be combined to predict the total deficit at a point</p><pre><code class="language-julia hljs">wakecombinationmodel = ff.LinearLocalVelocitySuperposition()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinearLocalVelocitySuperposition()</code></pre><p>The local turbulence intensity models can be used to estimate the local turbulence intensity at each wind turbine or point to provide more accurate input information to the wake and deflection models if applicable.</p><pre><code class="language-julia hljs">localtimodel = ff.LocalTIModelMaxTI()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LocalTIModelMaxTI{Float64, Float64, Float64, Float64}(2.32, 0.154, 0.3837, 0.003678)</code></pre><p>Initialize model set. This is just a convenience container for the analysis models.</p><pre><code class="language-julia hljs">modelset = ff.WindFarmModelSet(wakedeficitmodel, wakedeflectionmodel, wakecombinationmodel, localtimodel)</code></pre><h2 id="(3)-Running-the-analysis"><a class="docs-heading-anchor" href="#(3)-Running-the-analysis">(3) Running the analysis</a><a id="(3)-Running-the-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#(3)-Running-the-analysis" title="Permalink"></a></h2><p>Now that the wind farm and analysis models have been defined, we can calculate AEP. The output is in Watt-hours.</p><pre><code class="language-julia hljs">aep = ff.calculate_aep(turbinex, turbiney, turbinez, rotordiameter,
    hubheight, turbineyaw, ctmodels, generatorefficiency, cutinspeed,
    cutoutspeed, ratedspeed, ratedpower, windresource, powermodels, modelset,
    rotor_sample_points_y=rotorsamplepointsy, rotor_sample_points_z=rotorsamplepointsz)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4.1752381500085173e9</code></pre><p>We can also get the AEP in each direction using the following.</p><pre><code class="language-julia hljs">state_aeps = ff.calculate_state_aeps(turbinex, turbiney, turbinez, rotordiameter,
        hubheight, turbineyaw, ctmodels, generatorefficiency, cutinspeed,
        cutoutspeed, ratedspeed, ratedpower, windresource, powermodels, modelset,
        rotor_sample_points_y=rotorsamplepointsy, rotor_sample_points_z=rotorsamplepointsz,
        hours_per_year=365.25*24.0, weighted=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Float64}:
 4.238504382525765e8
 9.75999028763892e8
 8.989462395040804e8
 8.934110908062623e8
 9.830313526817064e8</code></pre><p>If we instead set <code>weighted=false</code> then we would get the power in each direction in Watts.</p><p>If we want to get the individual turbine powers in each directions, we use the following.</p><pre><code class="language-julia hljs">turbine_powers_by_direction = ff.calculate_state_turbine_powers(turbinex, turbiney, turbinez, rotordiameter,
    hubheight, turbineyaw, ctmodels, generatorefficiency, cutinspeed,
    cutoutspeed, ratedspeed, ratedpower, windresource, powermodels, modelset,
    rotor_sample_points_y=rotorsamplepointsy, rotor_sample_points_z=rotorsamplepointsz)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5×9 Matrix{Float64}:
  2544.31   6417.76  71624.0   2544.31  …   2544.31   6417.76  71624.0
 50455.7   50455.7   60389.0  60173.9      71624.0   71624.0   71624.0
 71624.0   41504.8   35763.4  71624.0      71624.0   71616.9   71616.9
 71624.0   71618.3   71618.3  71624.0      71624.0   40492.8   35288.1
 71624.0   71624.0   71624.0  61031.2      50765.9   50765.9   61207.3</code></pre><p>The output shows each turbine power in an array that is ndirections by nturbines.</p><h2 id="(4)-setting-up-and-running-an-optimization"><a class="docs-heading-anchor" href="#(4)-setting-up-and-running-an-optimization">(4) setting up and running an optimization</a><a id="(4)-setting-up-and-running-an-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#(4)-setting-up-and-running-an-optimization" title="Permalink"></a></h2><p>FLOWFarm is specifically designed for efficient optimization using gradient-based optimization methods. Besides the steps outlined above, we need to define the following before we can run  an optimization:</p><ul><li>(1) Optimization related variables</li><li>(1) A container for non-differentiated parameters</li><li>(2) Objective function </li><li>(3) Constraint function(s) </li><li>(4) Optimization tool specific items</li></ul><p>In this tutorial we demonstrate optimizing using the IPOPT algorithms via SNOW.jl for simplicity.</p><p>First, set up optimization related variables. We will have two constraints, one to keep  turbines from getting too close to each other (spacing), and the other to keep turbines  inside the desired area (boundary). FLOWFarm provides several different ways of handling  boundary constraints, including concave boundaries. However, for this tutorial we will use  a simple circular boundary.</p><pre><code class="language-julia hljs"># scale objective derivatives to be between 0 and 1
objectivescale = 1E-6

# scale boundary constraint derivatives to be between 0 and 1
constraintscaleboundary = 1.0E-3

# scale spacing constraint derivatives to be between 0 and 1
constraintscalespacing = 1.0

# set the minimum spacing between turbines
minimumspacing = 160.0</code></pre><p>Next, set up a container for non-differentiated parameters</p><pre><code class="language-julia hljs"># set up a struct for use in optimization functions
mutable struct params_struct{}
    modelset
    rotorsamplepointsy
    rotorsamplepointsz
    turbinez
    ambientti
    rotordiameter
    boundarycenter
    boundaryradius
    objectivescale
    constraintscaleboundary
    constraintscalespacing
    minimumspacing
    hubheight
    turbineyaw
    ctmodels
    generatorefficiency
    cutinspeed
    cutoutspeed
    ratedspeed
    ratedpower
    windresource
    powermodels
end

params = params_struct(modelset, rotorsamplepointsy, rotorsamplepointsz, turbinez, ambientti,
    rotordiameter, boundarycenter, boundaryradius, objectivescale, constraintscaleboundary,
    constraintscalespacing, minimumspacing, hubheight, turbineyaw,
    ctmodels, generatorefficiency, cutinspeed, cutoutspeed, ratedspeed, ratedpower,
    windresource, powermodels)</code></pre><p>Now we are ready to set up wrapper functions for the objective and constraints.</p><pre><code class="language-julia hljs"># set up boundary constraint wrapper function
function boundary_wrapper(x, params)
    # include relevant params
    boundarycenter = params.boundarycenter
    boundaryradius = params.boundaryradius
    constraintscaleboundary = params.constraintscaleboundary

    # find the number of turbines
    nturbines = Int(length(x)/2)

    # extract x and y locations of turbines from design variables vector
    turbinex = x[1:nturbines]
    turbiney = x[nturbines+1:end]

    # get and return boundary distances
    return ff.circle_boundary(boundarycenter, boundaryradius, turbinex, turbiney).*constraintscaleboundary
end

# set up spacing constraint wrapper function
function spacing_wrapper(x, params)
    # include relevant params
    rotordiameter = params.rotordiameter
    constraintscalespacing = params.constraintscalespacing
    minimumspacing = params.minimumspacing

    # get number of turbines
    nturbines = Int(length(x)/2)

    # extract x and y locations of turbines from design variables vector
    turbinex = x[1:nturbines]
    turbiney = x[nturbines+1:end]

    # get and return spacing distances
    return constraintscalespacing.*(minimumspacing .- ff.turbine_spacing(turbinex,turbiney))
end

# set up aep wrapper function
function aep_wrapper(x, params)

    # include relevant params
    turbinez = params.turbinez
    rotordiameter = params.rotordiameter
    hubheight = params.hubheight
    turbineyaw =params.turbineyaw
    ctmodels = params.ctmodels
    generatorefficiency = params.generatorefficiency
    cutinspeed = params.cutinspeed
    cutoutspeed = params.cutoutspeed
    ratedspeed = params.ratedspeed
    ratedpower = params.ratedpower
    windresource = params.windresource
    powermodels = params.powermodels
    modelset = params.modelset
    rotorsamplepointsy = params.rotorsamplepointsy
    rotorsamplepointsz = params.rotorsamplepointsy
    objectivescale = params.objectivescale

    # get number of turbines
    nturbines = Int(length(x)/2)

    # extract x and y locations of turbines from design variables vector
    turbinex = x[1:nturbines]
    turbiney = x[nturbines+1:end]

    # calculate AEP
    aep = objectivescale*ff.calculate_aep(turbinex, turbiney, turbinez, rotordiameter,
                hubheight, turbineyaw, ctmodels, generatorefficiency, cutinspeed,
                cutoutspeed, ratedspeed, ratedpower, windresource, powermodels, modelset,
                rotor_sample_points_y=rotorsamplepointsy,rotor_sample_points_z=rotorsamplepointsz)

    # return the AEP
    return aep
end

# set up optimization problem wrapper function
function wind_farm_opt!(g, x, params)

    nturbines = Int(length(x)/2)

    # calculate spacing constraint value and jacobian
    spacing_con = spacing_wrapper(x, params)

    # calculate boundary constraint and jacobian
    boundary_con = boundary_wrapper(x, params)

    # combine constaint values and jacobians into overall constaint value and jacobian arrays
    g[1:(end-nturbines)] = spacing_con[:]
    g[end-nturbines+1:end] = boundary_con[:]

    # calculate the objective function and jacobian (negative sign in order to maximize AEP)
    obj = -aep_wrapper(x, params)[1]

    return obj
end</code></pre><p>Because the optimizer will need to call the objective function without knowing about the params, we need to set up a method that will know the params values by default.</p><pre><code class="language-julia hljs"># generate objective function wrapper
obj_func!(g, x) = wind_farm_opt!(g, x, params)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">obj_func! (generic function with 1 method)</code></pre><p>Next we set up the optimizer.</p><pre><code class="language-julia hljs"># initialize design variable vector
x0 = [copy(turbinex);copy(turbiney)]

# set general lower and upper bounds for design variables
lx = zeros(length(x0)) .- boundaryradius
ux = zeros(length(x0)) .+ boundaryradius

# set general lower and upper bounds for constraints
ng = Int(nturbines + (nturbines)*(nturbines - 1)/2)
lg = [-Inf*ones(Int((nturbines)*(nturbines - 1)/2)); -Inf*ones(nturbines)]
ug = [zeros(Int((nturbines)*(nturbines - 1)/2)); zeros(nturbines)]

# IPOPT options
ip_options = Dict(
    &quot;max_iter&quot; =&gt; 50,
    &quot;tol&quot; =&gt; 1e-6
)
solver = IPOPT(ip_options)

# if using SNOPT, you can do the following instead:
# snopt_opt = Dict(
#    &quot;Derivative option&quot; =&gt; 1,
#    &quot;Major optimality tolerance&quot; =&gt; 1e-4,
# )
# solver = SNOPT(options=snopt_opt)

# initialize SNOW options
options = Options(solver=solver, derivatives=ForwardAD())  # choose AD derivatives</code></pre><p>Now that the optimizer is set up, we are ready to optimize and check the results.</p><pre><code class="language-julia hljs"># optimize
t1 = time() # start time
xopt, fopt, info, out = minimize(obj_func!, x0, ng, lx, ux, lg, ug, options)
t2 = time() # end time
clk = t2-t1 # approximate run time

# get final aep
aepfinal = -fopt/objectivescale

# print optimization results
println(&quot;Finished in : &quot;, clk, &quot; (s)&quot;)
println(&quot;info: &quot;, info)
println(&quot;Initial AEP: &quot;, aep)
println(&quot;Final AEP: &quot;, aepfinal)
println(&quot;AEP improvement (%) = &quot;, 100*(aepfinal - aep)/aep)

# extract final turbine locations
turbinexopt = copy(xopt[1:nturbines])
turbineyopt = copy(xopt[nturbines+1:end])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{Float64}:
 -255.3321422522677
  -20.870517689199836
  342.2633440285099
 -270.2572838263869
  -28.100255955275586
  339.0351057238568
 -274.4119235798617
   -1.7960958312420887
  331.3909717421626</code></pre><h2 id="(5)-Calculating-a-flow-field"><a class="docs-heading-anchor" href="#(5)-Calculating-a-flow-field">(5) Calculating a flow field</a><a id="(5)-Calculating-a-flow-field-1"></a><a class="docs-heading-anchor-permalink" href="#(5)-Calculating-a-flow-field" title="Permalink"></a></h2><p>It is helpful to visualize the whole flow-field, not just the turbine powers.</p><pre><code class="language-julia hljs"># define how many points should be in the flow field
xres = 1000
yres = 1000
zres = 1

# define flow field domain
maxy = boundaryradius*1.5
miny = -boundaryradius*1.5
maxx = boundaryradius*1.5
minx = -boundaryradius*1.5

# set up point grid for flow field
xrange = minx:(maxx-minx)/xres:maxx
yrange = miny:(maxy-miny)/yres:maxy
zrange = hubheight[1]

# run flowfarm
ffvelocities = ff.calculate_flow_field(xrange, yrange, zrange,
    modelset, turbinexopt, turbineyopt, turbinez, turbineyaw,
    rotordiameter, hubheight, ctmodels, rotorsamplepointsy, rotorsamplepointsz,
    windresource, wind_farm_state_id=5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×1001×1001 Array{Float64, 3}:
[:, :, 1] =
 8.0  8.0  8.0  8.0  8.0  8.0  8.0  8.0  …  8.0  8.0  8.0  8.0  8.0  8.0  8.0

[:, :, 2] =
 8.0  8.0  8.0  8.0  8.0  8.0  8.0  8.0  …  8.0  8.0  8.0  8.0  8.0  8.0  8.0

[:, :, 3] =
 8.0  8.0  8.0  8.0  8.0  8.0  8.0  8.0  …  8.0  8.0  8.0  8.0  8.0  8.0  8.0

;;; … 

[:, :, 999] =
 7.63577  7.62738  7.61892  7.6104  …  8.0  8.0  8.0  8.0  8.0  8.0  8.0

[:, :, 1000] =
 7.63331  7.62492  7.61646  7.60793  …  8.0  8.0  8.0  8.0  8.0  8.0  8.0

[:, :, 1001] =
 7.63086  7.62246  7.61399  7.60546  …  8.0  8.0  8.0  8.0  8.0  8.0  8.0</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Intro</a><a class="docs-footer-nextpage" href="../WindFarmStruct/">Wind Farm Struct »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Tuesday 18 February 2025 20:57">Tuesday 18 February 2025</span>. Using Julia version 1.10.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
